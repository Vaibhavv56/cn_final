<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>News App</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <nav>
        <div class="main-nav container flex">
            <a href="#" onclick="reload()" class="company-logo">
                <img src="./assets/logo.png" alt="company logo">
            </a>
            <div class="nav-links">
                <ul class="flex">
                    <li class="hover-link nav-item" id="ipl" onclick="onNavItemClick('ipl')">IPL</li>
                    <li class="hover-link nav-item" id="finance" onclick="onNavItemClick('finance')">Finance</li>
                    <li class="hover-link nav-item" id="politics" onclick="onNavItemClick('politics')">Politics</li>
                </ul>
            </div>
            <div class="search-bar flex">
                <input id="search-text" type="text" class="news-input" placeholder="e.g. Science">
                <button id="search-button" class="search-button">Search</button>
            </div>
        </div>
    </nav>
    

    <main>
        <div class="cards-container container flex" id="cards-container">
            
        </div>
    </main>

    <div>
        <p>
            <br>
            <br>
            <br>
            <br>
        </p>
    </div>
    
    <div>
        
        <h1>hammingcode</h1>
        <pre>
            1)WAP to convert a given Infix expression into its equivalent Postfix expression using stack.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
struct stack
{
    int size;
    int top;
    char *arr;
};
 
int stackTop(struct stack* sp){
    return sp->arr[sp->top];
}
 
int isEmpty(struct stack *ptr)
{
    if (ptr->top == -1)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
 
int isFull(struct stack *ptr)
{
    if (ptr->top == ptr->size - 1)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
 
void push(struct stack* ptr, char val){
    if(isFull(ptr)){
        printf("Stack Overflow! Cannot push %d to the stack\n", val);
    }
    else{
        ptr->top++;
        ptr->arr[ptr->top] = val;
    }
}
 
char pop(struct stack* ptr){
    if(isEmpty(ptr)){
        printf("Stack Underflow! Cannot pop from the stack\n");
        return -1;
    }
    else{
        char val = ptr->arr[ptr->top];
        ptr->top--;
        return val;
    }
}
int precedence(char ch){
    if(ch == '*' || ch=='/')
        return 3;
    else if(ch == '+' || ch=='-')
        return 2; 
    else
        return 0;
}
 
int isOperator(char ch){
    if(ch=='+' || ch=='-' ||ch=='*' || ch=='/') 
        return 1;
    else
        return 0;
}
char* infixToPostfix(char* infix){
    struct stack * sp = (struct stack *) malloc(sizeof(struct stack));
    sp->size = 10; 
    sp->top = -1;
    sp->arr = (char *) malloc(sp->size * sizeof(char));
    char * postfix = (char *) malloc((strlen(infix)+1) * sizeof(char));
    int i=0; // Track infix traversal
    int j = 0; // Track postfix addition 
    while (infix[i]!='\0')
    {
        if(!isOperator(infix[i])){
            postfix[j] = infix[i];
            j++;
            i++;
        }
        else{
            if(precedence(infix[i])> precedence(stackTop(sp))){
                push(sp, infix[i]);
                i++;
            }
            else{
                postfix[j] = pop(sp);
                j++;
            }
        }
    }
    while (!isEmpty(sp))    
    {
        postfix[j] = pop(sp);
        j++;
    }
    postfix[j] = '\0';
    return postfix;
}
int main()
{
    char * infix = "x-y/z-k*d";
    printf("postfix is %s", infixToPostfix(infix));
    return 0;
}


2)WAP to implement multiple stack i.e. More than two stacks using array and perform following operations on it. A. PUSH, B. POP, C. StackFull D. StackeEmpty E. Display Stack.

#include <stdio.h>
#include <stdlib.h>

#define MAX 100 // Maximum size of the array

struct MultiStack {
    int *arr;     // Array to hold stack elements
    int *top;     // Array to hold the top index of each stack
    int numStacks; // Number of stacks
    int size;      // Size of each stack
};

// Function to initialize multiple stacks
void initMultiStack(struct MultiStack *ms, int numStacks, int size) {
    ms->numStacks = numStacks;
    ms->size = size;
    ms->arr = (int *)malloc(numStacks * size * sizeof(int));
    ms->top = (int *)malloc(numStacks * sizeof(int));

    // Initialize top of each stack
    for (int i = 0; i < numStacks; i++) {
        ms->top[i] = i * size - 1; // Each stack starts from index `(i * size)`
    }
}

// Function to check if a specific stack is empty
int isStackEmpty(struct MultiStack *ms, int stackNum) {
    return ms->top[stackNum] < stackNum * ms->size;
}

// Function to check if a specific stack is full
int isStackFull(struct MultiStack *ms, int stackNum) {
    return ms->top[stackNum] >= (stackNum + 1) * ms->size - 1;
}

// Function to push an element onto a specific stack
void push(struct MultiStack *ms, int stackNum, int value) {
    if (isStackFull(ms, stackNum)) {
        printf("Stack %d Overflow\n", stackNum);
    } else {
        ms->top[stackNum]++;
        ms->arr[ms->top[stackNum]] = value;
        printf("Pushed %d to Stack %d\n", value, stackNum);
    }
}

// Function to pop an element from a specific stack
int pop(struct MultiStack *ms, int stackNum) {
    if (isStackEmpty(ms, stackNum)) {
        printf("Stack %d Underflow\n", stackNum);
        return -1; // Return an error code
    } else {
        int value = ms->arr[ms->top[stackNum]];
        ms->top[stackNum]--;
        return value;
    }
}

// Function to display the contents of a specific stack
void displayStack(struct MultiStack *ms, int stackNum) {
    if (isStackEmpty(ms, stackNum)) {
        printf("Stack %d is Empty\n", stackNum);
    } else {
        printf("Stack %d contents: ", stackNum);
        for (int i = stackNum * ms->size; i <= ms->top[stackNum]; i++) {
            printf("%d ", ms->arr[i]);
        }
        printf("\n");
    }
}

int main() {
    int numStacks = 3; // Number of stacks
    int sizePerStack = 5; // Size of each stack

    struct MultiStack ms;
    initMultiStack(&ms, numStacks, sizePerStack);

    // Performing operations directly
    push(&ms, 0, 10); // Push 10 to Stack 0
    push(&ms, 0, 20); // Push 20 to Stack 0
    push(&ms, 1, 30); // Push 30 to Stack 1
    push(&ms, 2, 40); // Push 40 to Stack 2

    displayStack(&ms, 0); // Display Stack 0
    displayStack(&ms, 1); // Display Stack 1
    displayStack(&ms, 2); // Display Stack 2

    int poppedValue = pop(&ms, 0); // Pop from Stack 0
    if (poppedValue != -1) {
        printf("Popped %d from Stack 0\n", poppedValue);
    }

    displayStack(&ms, 0); // Display Stack 0 after popping

    // Free allocated memory
    free(ms.arr);
    free(ms.top);

    return 0;
}
3.WAP to convert a given Infix expression into its equivalent Prefix expression using stack.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
struct stack
{
    int size;
    int top;
    char *arr;
};
 
int stackTop(struct stack* sp){
    return sp->arr[sp->top];
}
 
int isEmpty(struct stack *ptr)
{
    if (ptr->top == -1)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
 
int isFull(struct stack *ptr)
{
    if (ptr->top == ptr->size - 1)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
 
void push(struct stack* ptr, char val){
    if(isFull(ptr)){
        printf("Stack Overflow! Cannot push %d to the stack\n", val);
    }
    else{
        ptr->top++;
        ptr->arr[ptr->top] = val;
    }
}
 
char pop(struct stack* ptr){
    if(isEmpty(ptr)){
        printf("Stack Underflow! Cannot pop from the stack\n");
        return -1;
    }
    else{
        char val = ptr->arr[ptr->top];
        ptr->top--;
        return val;
    }
}
int precedence(char ch){
    if(ch == '*' || ch=='/')
        return 3;
    else if(ch == '+' || ch=='-')
        return 2; 
    else
        return 0;
}
 
int isOperator(char ch){
    if(ch=='+' || ch=='-' ||ch=='*' || ch=='/') 
        return 1;
    else
        return 0;
}
char* infixToPostfix(char* infix){
    struct stack * sp = (struct stack *) malloc(sizeof(struct stack));
    sp->size = 10; 
    sp->top = -1;
    sp->arr = (char *) malloc(sp->size * sizeof(char));
    char * postfix = (char *) malloc((strlen(infix)+1) * sizeof(char));
    int i=0; // Track infix traversal
    int j = 0; // Track postfix addition 
    while (infix[i]!='\0')
    {
        if(!isOperator(infix[i])){
            postfix[j] = infix[i];
            j++;
            i++;
        }
        else{
            if(precedence(infix[i])> precedence(stackTop(sp))){
                push(sp, infix[i]);
                i++;
            }
            else{
                postfix[j] = pop(sp);
                j++;
            }
        }
    }
    while (!isEmpty(sp))    
    {
        postfix[j] = pop(sp);
        j++;
    }
    postfix[j] = '\0';
    return postfix;
}
int main()
{
    char * infix = "x-y/z-k*d";
    printf("postfix is %s", infixToPostfix(infix));
    return 0;
}




4)A person is living in house having 5 rooms. These rooms are adjacent to each other. There is a treasure which is electronically locked and to unlock it we need a code. In last room there is a box in which some decimal number is written. We need to convert that number into binary to open treasure which is kept in room no.1 . We need to move from room no.1 to 2 to 3 and so on and follow the reverse way to come back i.e. from 5 to 4 to 3 etc. Apply suitable logic to implement this scenario by using stacks.
#include <stdio.h>
#include <stdlib.h>

struct stack {
    int top;
    int size;
    int *arr;
};

// Stack functions
int isEmpty(struct stack *s) { return s->top == -1; }
int isFull(struct stack *s) { return s->top == s->size - 1; }
void push(struct stack *s, int val) {
    if (!isFull(s)) {
        s->arr[++s->top] = val;
    }
}
int pop(struct stack *s) {
    return isEmpty(s) ? -1 : s->arr[s->top--];
}

// Convert decimal to binary using stack
void decimalToBinary(int num) {
    struct stack *binaryStack = (struct stack *)malloc(sizeof(struct stack));
    binaryStack->top = -1;
    binaryStack->size = 32;  // Sufficient for binary representation
    binaryStack->arr = (int *)malloc(binaryStack->size * sizeof(int));

    printf("\nConverting %d to binary: ", num);

    while (num > 0) {
        push(binaryStack, num % 2);
        num /= 2;
    }

    while (!isEmpty(binaryStack)) {
        printf("%d", pop(binaryStack));  // Print binary representation
    }

    free(binaryStack->arr);
    free(binaryStack);
}

int main() {
    struct stack *roomStack = (struct stack *)malloc(sizeof(struct stack));
    roomStack->top = -1;
    roomStack->size = 5;  // Five rooms
    roomStack->arr = (int *)malloc(roomStack->size * sizeof(int));

    printf("Entering rooms in sequence:\n");
    for (int i = 1; i <= 5; i++) {
        push(roomStack, i);
        printf("Entered Room %d\n", i);
    }

    // Room 5: Find the number
    int decimalNumber = 23;  // Example number in room 5
    printf("\nFound a decimal number %d in Room 5.\n", decimalNumber);

    // Convert the number to binary
    decimalToBinary(decimalNumber);
    printf("\nTreasure unlocked!\n");

    printf("\nReturning through rooms in reverse:\n");
    while (!isEmpty(roomStack)) {
        printf("Exited Room %d\n", pop(roomStack));
    }

    free(roomStack->arr);
    free(roomStack);
    return 0;
}

5)WAP to implement following by using stack. A. Factorial of a given number 
#include <stdio.h>
#include <stdlib.h>

struct stack {
    int top;
    int size;
    int *arr;
};

void push(struct stack *s, int val) {
    if (s->top < s->size - 1) {
        s->arr[++s->top] = val;
    }
}

int pop(struct stack *s) {
    return (s->top == -1) ? 1 : s->arr[s->top--];
}

int factorialUsingStack(int n) {
    struct stack *s = (struct stack *)malloc(sizeof(struct stack));
    s->size = n;
    s->top = -1;
    s->arr = (int *)malloc(s->size * sizeof(int));

    // Push numbers onto the stack
    for (int i = 1; i <= n; i++) {
        push(s, i);
    }

    // Multiply numbers while popping
    int result = 1;
    while (s->top != -1) {
        result *= pop(s);
    }

    free(s->arr);
    free(s);
    return result;
}

int main() {
    int num = 5;  // Example
    printf("Factorial of %d is %d\n", num, factorialUsingStack(num));
    return 0;
}


B. Generation of Fibonacci series We Fly Anywhere Airlines (WFAA) is considering redesigning their ticket counters for airline passengers. They would like to have two separate waiting lines, one for regular customers and one for frequent flyers. Assuming there is only one ticket agent available to serve all passengers, they would like to determine the average waiting time for both types of passengers using various strategies for taking passengers from the waiting lines. WAP to simulate this situation.
#include <stdio.h>
#include <stdlib.h>

struct stack {
    int top;
    int size;
    int *arr;
};

void push(struct stack *s, int val) {
    if (s->top < s->size - 1) {
        s->arr[++s->top] = val;
    }
}

int pop(struct stack *s) {
    return (s->top == -1) ? 0 : s->arr[s->top--];
}

void generateFibonacci(int n) {
    struct stack *s = (struct stack *)malloc(sizeof(struct stack));
    s->size = n;
    s->top = -1;
    s->arr = (int *)malloc(s->size * sizeof(int));

    push(s, 1);  // First Fibonacci number
    push(s, 1);  // Second Fibonacci number

    printf("Fibonacci Series: 1 1 ");
    for (int i = 3; i <= n; i++) {
        int second = pop(s);
        int first = pop(s);
        int next = first + second;

        printf("%d ", next);
        push(s, second);
        push(s, next);
    }

    printf("\n");

    free(s->arr);
    free(s);
}

int main() {
    int terms = 10;  // Example
    generateFibonacci(terms);
    return 0;
}


#include <stdio.h>
#include <stdlib.h>

struct queue {
    int front, rear, size;
    int *arr;
};

struct queue* createQueue(int size) {
    struct queue *q = (struct queue *)malloc(sizeof(struct queue));
    q->size = size;
    q->front = q->rear = -1;
    q->arr = (int *)malloc(size * sizeof(int));
    return q;
}

int isQueueEmpty(struct queue *q) {
    return q->front == -1;
}

int isQueueFull(struct queue *q) {
    return (q->rear + 1) % q->size == q->front;
}

void enqueue(struct queue *q, int val) {
    if (!isQueueFull(q)) {
        if (q->front == -1) q->front = 0;
        q->rear = (q->rear + 1) % q->size;
        q->arr[q->rear] = val;
    }
}

int dequeue(struct queue *q) {
    if (isQueueEmpty(q)) return -1;
    int val = q->arr[q->front];
    if (q->front == q->rear) q->front = q->rear = -1;  // Reset queue
    else q->front = (q->front + 1) % q->size;
    return val;
}

void simulateAirlineCounter() {
    struct queue *frequentFlyers = createQueue(10);
    struct queue *regularCustomers = createQueue(10);

    // Simulating arrivals
    enqueue(frequentFlyers, 1);  // Frequent flyer IDs
    enqueue(frequentFlyers, 2);
    enqueue(regularCustomers, 101);  // Regular customer IDs
    enqueue(regularCustomers, 102);

    int strategy = 1;  // 1: Serve frequent flyers first, then regular customers

    printf("Serving passengers:\n");
    while (!isQueueEmpty(frequentFlyers) || !isQueueEmpty(regularCustomers)) {
        if (strategy == 1) {
            if (!isQueueEmpty(frequentFlyers)) {
                printf("Served Frequent Flyer ID: %d\n", dequeue(frequentFlyers));
            } else if (!isQueueEmpty(regularCustomers)) {
                printf("Served Regular Customer ID: %d\n", dequeue(regularCustomers));
            }
        } else {
            if (!isQueueEmpty(regularCustomers)) {
                printf("Served Regular Customer ID: %d\n", dequeue(regularCustomers));
            } else if (!isQueueEmpty(frequentFlyers)) {
                printf("Served Frequent Flyer ID: %d\n", dequeue(frequentFlyers));
            }
        }
    }

    free(frequentFlyers->arr);
    free(regularCustomers->arr);
    free(frequentFlyers);
    free(regularCustomers);
}

int main() {
    simulateAirlineCounter();
    return 0;
}

6)An operating system assigns job to print queues based on the number of pages to be printed (1 to 50 pages). You may assume that the system printers are able to print 10 page per minute. Smaller print jobs are printed before larger print jobs and print jobs are processed from a single print queue implemented as a priority queue). The system administrators would like to compare the time required to process a set of print jobs using 1, 2, or 3 system printers. Write a program which simulates processing 100 print jobs of varying lengths using either 1, 2, or 3 printers. Assume that a print request is made every minute and that the number of pages to print varies from 1 to 50 pages. To be fair, you will need to process the same set of print jobs each time you add a printer.The output from your program should indicate the order in which the jobs were received, the order in which they were printed, and the time required to process the set of print jobs. If more than one printer is being used, indicate which printer each job was printed on. 
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Define job structure
typedef struct {
    int jobId;
    int pages;
    int arrivalTime;
} Job;

// Define priority queue node
typedef struct {
    Job job;
    int priority; // Number of pages (smaller is higher priority)
} PriorityQueueNode;

// Define priority queue
typedef struct {
    PriorityQueueNode *heap;
    int size;
    int capacity;
} PriorityQueue;

// Priority queue functions
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *pq = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    pq->heap = (PriorityQueueNode *)malloc(capacity * sizeof(PriorityQueueNode));
    pq->size = 0;
    pq->capacity = capacity;
    return pq;
}

void swap(PriorityQueueNode *a, PriorityQueueNode *b) {
    PriorityQueueNode temp = *a;
    *a = *b;
    *b = temp;
}

void heapifyUp(PriorityQueue *pq, int idx) {
    if (idx && pq->heap[idx].priority < pq->heap[(idx - 1) / 2].priority) {
        swap(&pq->heap[idx], &pq->heap[(idx - 1) / 2]);
        heapifyUp(pq, (idx - 1) / 2);
    }
}

void heapifyDown(PriorityQueue *pq, int idx) {
    int smallest = idx;
    int left = 2 * idx + 1;
    int right = 2 * idx + 2;

    if (left < pq->size && pq->heap[left].priority < pq->heap[smallest].priority) {
        smallest = left;
    }
    if (right < pq->size && pq->heap[right].priority < pq->heap[smallest].priority) {
        smallest = right;
    }
    if (smallest != idx) {
        swap(&pq->heap[idx], &pq->heap[smallest]);
        heapifyDown(pq, smallest);
    }
}

void enqueue(PriorityQueue *pq, Job job) {
    if (pq->size == pq->capacity) return;
    PriorityQueueNode node = {job, job.pages};
    pq->heap[pq->size] = node;
    heapifyUp(pq, pq->size++);
}

Job dequeue(PriorityQueue *pq) {
    Job job = pq->heap[0].job;
    pq->heap[0] = pq->heap[--pq->size];
    heapifyDown(pq, 0);
    return job;
}

int isEmpty(PriorityQueue *pq) {
    return pq->size == 0;
}

// Simulate print jobs with 1, 2, or 3 printers
void simulatePrintJobs(int numPrinters) {
    int numJobs = 100, printSpeed = 10; // 10 pages/min
    PriorityQueue *pq = createPriorityQueue(numJobs);

    // Generate random print jobs
    srand(time(0));
    Job jobs[numJobs];
    for (int i = 0; i < numJobs; i++) {
        jobs[i].jobId = i + 1;
        jobs[i].pages = (rand() % 50) + 1; // 1 to 50 pages
        jobs[i].arrivalTime = i; // 1 job per minute
        enqueue(pq, jobs[i]);
    }

    printf("Simulation with %d printer(s):\n", numPrinters);
    printf("Job Reception Order: ");
    for (int i = 0; i < numJobs; i++) {
        printf("Job%d(%d pages) ", jobs[i].jobId, jobs[i].pages);
    }
    printf("\n");

    int currentTime = 0;
    int printerAvailability[numPrinters]; // Tracks when each printer will be free
    for (int i = 0; i < numPrinters; i++) printerAvailability[i] = 0;

    printf("Print Order:\n");
    while (!isEmpty(pq)) {
        for (int i = 0; i < numPrinters && !isEmpty(pq); i++) {
            if (printerAvailability[i] <= currentTime) {
                Job job = dequeue(pq);
                int finishTime = currentTime + (job.pages + printSpeed - 1) / printSpeed; // Round up
                printerAvailability[i] = finishTime;
                printf("Job%d(%d pages) completed on Printer%d at minute %d\n",
                       job.jobId, job.pages, i + 1, finishTime);
            }
        }
        currentTime++;
    }

    printf("\nTotal time required: %d minutes\n\n", currentTime);
    free(pq->heap);
    free(pq);
}

int main() {
    simulatePrintJobs(1); // Simulate with 1 printer
    simulatePrintJobs(2); // Simulate with 2 printers
    simulatePrintJobs(3); // Simulate with 3 printers
    return 0;
}

7)Write a program which simulates the operation of a busy airport which has only two runways to handle all takeoffs and landings. You may assume that each takeoff or landing takes 15 minutes to complete. One runway request is made during each five minute time interval and likelihood of landing request is the same as for takeoff. Priority is given to planes requesting a landing. If a request cannot be honored it is added to a takeoff or landing queue. Your program should simulate 120 minutes of activity at the airport. Each request for runway clearance should be time-stamped and added to the appropriate queue. The output from your program should include the final queue contents, the number of take offs completed, the number of landings completed, and the average number of minutes spent in each queue.
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct {
    int requestId;
    int timestamp;
} Request;

typedef struct {
    Request *requests;
    int front, rear, size, capacity;
} Queue;

// Initialize a queue
Queue *createQueue(int capacity) {
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    queue->requests = (Request *)malloc(capacity * sizeof(Request));
    queue->front = 0;
    queue->rear = -1;
    queue->size = 0;
    queue->capacity = capacity;
    return queue;
}

// Enqueue a request
void enqueue(Queue *queue, int requestId, int timestamp) {
    if (queue->size == queue->capacity) return;
    queue->rear = (queue->rear + 1) % queue->capacity;
    queue->requests[queue->rear].requestId = requestId;
    queue->requests[queue->rear].timestamp = timestamp;
    queue->size++;
}

// Dequeue a request
Request dequeue(Queue *queue) {
    Request request = queue->requests[queue->front];
    queue->front = (queue->front + 1) % queue->capacity;
    queue->size--;
    return request;
}

// Check if queue is empty
int isEmpty(Queue *queue) {
    return queue->size == 0;
}

// Simulate the airport activity
void simulateAirport(int totalTime) {
    int takeoffCount = 0, landingCount = 0;
    int totalTakeoffWait = 0, totalLandingWait = 0;

    Queue *takeoffQueue = createQueue(50);
    Queue *landingQueue = createQueue(50);

    int currentTime = 0, nextTakeoffRunwayFree = 0, nextLandingRunwayFree = 0;
    srand(time(0));

    for (int time = 0; time <= totalTime; time += 5) {
        // Randomly generate a request
        int isLanding = rand() % 2;
        if (isLanding) {
            enqueue(landingQueue, landingCount + takeoffCount + 1, time);
        } else {
            enqueue(takeoffQueue, landingCount + takeoffCount + 1, time);
        }

        // Process landing requests (priority)
        if (time >= nextLandingRunwayFree && !isEmpty(landingQueue)) {
            Request landing = dequeue(landingQueue);
            nextLandingRunwayFree = time + 15;
            totalLandingWait += time - landing.timestamp;
            landingCount++;
        } else if (time >= nextTakeoffRunwayFree && !isEmpty(takeoffQueue)) {
            // Process takeoff requests if no landing
            Request takeoff = dequeue(takeoffQueue);
            nextTakeoffRunwayFree = time + 15;
            totalTakeoffWait += time - takeoff.timestamp;
            takeoffCount++;
        }
    }

    // Output results
    printf("Simulation Results:\n");
    printf("Total landings completed: %d\n", landingCount);
    printf("Total takeoffs completed: %d\n", takeoffCount);
    printf("Average landing wait time: %.2f minutes\n", landingCount ? (float)totalLandingWait / landingCount : 0);
    printf("Average takeoff wait time: %.2f minutes\n", takeoffCount ? (float)totalTakeoffWait / takeoffCount : 0);

    // Print final queue contents
    printf("\nFinal Landing Queue:\n");
    while (!isEmpty(landingQueue)) {
        Request r = dequeue(landingQueue);
        printf("Request ID: %d, Timestamp: %d minutes\n", r.requestId, r.timestamp);
    }

    printf("\nFinal Takeoff Queue:\n");
    while (!isEmpty(takeoffQueue)) {
        Request r = dequeue(takeoffQueue);
        printf("Request ID: %d, Timestamp: %d minutes\n", r.requestId, r.timestamp);
    }

    // Free memory
    free(takeoffQueue->requests);
    free(takeoffQueue);
    free(landingQueue->requests);
    free(landingQueue);
}

int main() {
    int simulationTime = 120; // Total time in minutes
    simulateAirport(simulationTime);
    return 0;
}

8)Write a Program to implement circular double ended queue where user can add and remove the elements from both front and rear of the queue
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int *arr;
    int front, rear, size, capacity;
} Deque;

// Initialize the deque
Deque* createDeque(int capacity) {
    Deque* dq = (Deque*)malloc(sizeof(Deque));
    dq->arr = (int*)malloc(capacity * sizeof(int));
    dq->front = -1;
    dq->rear = -1;
    dq->capacity = capacity;
    dq->size = 0;
    return dq;
}

// Check if the deque is empty
int isEmpty(Deque* dq) {
    return dq->size == 0;
}

// Check if the deque is full
int isFull(Deque* dq) {
    return dq->size == dq->capacity;
}

// Add an element to the front
void addFront(Deque* dq, int data) {
    if (isFull(dq)) {
        printf("Deque is full! Cannot add %d to the front.\n", data);
        return;
    }
    if (dq->front == -1) {
        dq->front = dq->rear = 0;
    } else {
        dq->front = (dq->front - 1 + dq->capacity) % dq->capacity;
    }
    dq->arr[dq->front] = data;
    dq->size++;
    printf("Added %d to the front.\n", data);
}

// Add an element to the rear
void addRear(Deque* dq, int data) {
    if (isFull(dq)) {
        printf("Deque is full! Cannot add %d to the rear.\n", data);
        return;
    }
    if (dq->rear == -1) {
        dq->front = dq->rear = 0;
    } else {
        dq->rear = (dq->rear + 1) % dq->capacity;
    }
    dq->arr[dq->rear] = data;
    dq->size++;
    printf("Added %d to the rear.\n", data);
}

// Remove an element from the front
void removeFront(Deque* dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty! Cannot remove from the front.\n");
        return;
    }
    printf("Removed %d from the front.\n", dq->arr[dq->front]);
    if (dq->front == dq->rear) {
        dq->front = dq->rear = -1;
    } else {
        dq->front = (dq->front + 1) % dq->capacity;
    }
    dq->size--;
}

// Remove an element from the rear
void removeRear(Deque* dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty! Cannot remove from the rear.\n");
        return;
    }
    printf("Removed %d from the rear.\n", dq->arr[dq->rear]);
    if (dq->front == dq->rear) {
        dq->front = dq->rear = -1;
    } else {
        dq->rear = (dq->rear - 1 + dq->capacity) % dq->capacity;
    }
    dq->size--;
}

// Display the contents of the deque
void display(Deque* dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty.\n");
        return;
    }
    printf("Deque contents: ");
    int i = dq->front;
    for (int count = 0; count < dq->size; count++) {
        printf("%d ", dq->arr[i]);
        i = (i + 1) % dq->capacity;
    }
    printf("\n");
}

// Main function
int main() {
    int capacity = 5; // Set the deque capacity
    Deque* dq = createDeque(capacity);

    // Performing operations
    addFront(dq, 10);
    addRear(dq, 20);
    addFront(dq, 30);
    addRear(dq, 40);
    removeFront(dq);
    removeRear(dq);
    addFront(dq, 50);
    display(dq); // Display the current state of the deque

    free(dq->arr);
    free(dq);

    return 0;
}
9)Write a Program to implement multiple queue i.e. two queues using array and perform following operations on it. A. Addq, B. Delq, C. Display Queue. Given a list, split it into two sublists â€” one for the front half, and one for the back half. If the number of elements is odd, the extra element should go in the front list. So FrontBackSplit() on the list {2, 3, 5, 7, 11} should yield the two lists {2, 3, 5} and {7, 11}. Getting this right for all the cases is harder than it looks. You should check your solution against a few cases (length = 2, length = 3, length=4) to make sure that the list gets split correctly near the short-list boundary conditions. If it works right for length=4, it probably works right for length=1000. You will probably need special case code to deal with the (length <2) cases. 
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 50  // Maximum size of the queues

// Define the Queue structure
typedef struct {
    int front, rear;
    int arr[MAX_SIZE];
} Queue;

// Function to initialize the queue
void initQueue(Queue* q) {
    q->front = q->rear = -1;
}

// Function to check if the queue is empty
int isEmpty(Queue* q) {
    return q->front == -1;
}

// Function to check if the queue is full
int isFull(Queue* q) {
    return q->rear == MAX_SIZE - 1;
}

// Function to add an element to the queue (enqueue)
void Addq(Queue* q, int value) {
    if (isFull(q)) {
        printf("Queue Overflow! Cannot add more elements.\n");
    } else {
        if (q->front == -1) {
            q->front = 0;  // Set front if the queue is empty
        }
        q->rear++;
        q->arr[q->rear] = value;
        printf("Added %d to the queue\n", value);
    }
}

// Function to delete an element from the queue (dequeue)
int Delq(Queue* q) {
    if (isEmpty(q)) {
        printf("Queue Underflow! No elements to delete.\n");
        return -1;
    } else {
        int value = q->arr[q->front];
        if (q->front == q->rear) {
            q->front = q->rear = -1;  // Reset queue if it becomes empty
        } else {
            q->front++;
        }
        return value;
    }
}

// Function to display the elements of the queue
void displayQueue(Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty.\n");
    } else {
        printf("Queue elements: ");
        for (int i = q->front; i <= q->rear; i++) {
            printf("%d ", q->arr[i]);
        }
        printf("\n");
    }
}

// Function to split the list into two sublists
void FrontBackSplit(int* list, int length) {
    int i;
    Queue q1, q2;
    initQueue(&q1);
    initQueue(&q2);

    int mid = (length + 1) / 2;  // If odd, the extra element goes to the front half

    // Add the first half of the list to the first queue (q1)
    for (i = 0; i < mid; i++) {
        Addq(&q1, list[i]);
    }

    // Add the second half of the list to the second queue (q2)
    for (i = mid; i < length; i++) {
        Addq(&q2, list[i]);
    }

    // Display the two queues (front and back)
    printf("Front Queue: ");
    displayQueue(&q1);
    printf("Back Queue: ");
    displayQueue(&q2);
}

int main() {
    // Simulating two queues with one list and performing the operations
    Queue q1, q2;
    initQueue(&q1);
    initQueue(&q2);

    // Add elements to the first queue
    Addq(&q1, 1);
    Addq(&q1, 2);
    Addq(&q1, 3);

    // Add elements to the second queue
    Addq(&q2, 4);
    Addq(&q2, 5);

    // Display both queues
    printf("Queue 1:\n");
    displayQueue(&q1);
    printf("Queue 2:\n");
    displayQueue(&q2);

    // Perform dequeue on both queues
    printf("Dequeued from Queue 1: %d\n", Delq(&q1));
    printf("Dequeued from Queue 2: %d\n", Delq(&q2));

    // Display both queues after dequeuing
    printf("Queue 1 after Dequeue:\n");
    displayQueue(&q1);
    printf("Queue 2 after Dequeue:\n");
    displayQueue(&q2);

    // List to split
    int list[] = {2, 3, 5, 7, 11};
    int length = sizeof(list) / sizeof(list[0]);

    // Split the list into two sublists (queues)
    printf("\nSplitting the list into two sublists:\n");
    FrontBackSplit(list, length);

    return 0;
}
10)WAP to perform addition o f two polynomials using singly linked list.
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a node
struct node {
    int data;
    struct node* next;
};

// Function prototypes
struct node* create(int n);
void display(struct node* head);
struct node* add(struct node* l1, struct node* l2);

int main() {
    int n1, n2;
    struct node *head1, *head2, *sum;

    // Ask for the number of nodes in the first number
    printf("Enter the number of nodes for the first number: ");
    scanf("%d", &n1);
    head1 = create(n1);

    // Ask for the number of nodes in the second number
    printf("Enter the number of nodes for the second number: ");
    scanf("%d", &n2);
    head2 = create(n2);

    // Display the linked lists
    printf("First Number: ");
    display(head1);
    printf("Second Number: ");
    display(head2);

    // Add the two numbers
    sum = add(head1, head2);

    // Display the result
    printf("Sum: ");
    display(sum);

    return 0;
}

// Function to create a linked list with n nodes
struct node* create(int n) {
    int value, i;
    struct node *head, *p;

    // Create the first node
    printf("Enter the first node: ");
    scanf("%d", &value);

    head = (struct node*)malloc(sizeof(struct node));
    head->data = value;
    head->next = NULL;
    p = head;

    // Create the remaining nodes
    for (i = 1; i < n; i++) {
        p->next = (struct node*)malloc(sizeof(struct node));
        p = p->next;
        printf("Enter node %d: ", i + 1);
        scanf("%d", &p->data);
        p->next = NULL;
    }

    return head;  // Return the head of the linked list
}

// Function to display the linked list
void display(struct node* head) {
    struct node* p = head;

    // Traverse the list and print the data
    while (p != NULL) {
        printf("%d\t", p->data);
        p = p->next;
    }
    printf("\n");
}

// Function to add two numbers represented by linked lists
struct node* add(struct node* l1, struct node* l2) {
    struct node *result = NULL, *temp, *prev = NULL;
    int carry = 0, sum;

    // Traverse both lists
    while (l1 != NULL || l2 != NULL) {
        // Sum the digits of both lists and the carry
        sum = carry;
        if (l1 != NULL) {
            sum += l1->data;
            l1 = l1->next;
        }
        if (l2 != NULL) {
            sum += l2->data;
            l2 = l2->next;
        }

        // Calculate carry for the next iteration
        carry = sum / 10;
        
        // Create a new node for the current digit of the result
        temp = (struct node*)malloc(sizeof(struct node));
        temp->data = sum % 10;
        temp->next = NULL;

        // If this is the first node, set it as the result head
        if (result == NULL) {
            result = temp;
        } else {
            prev->next = temp;
        }
        prev = temp;
    }

    // If there is a carry left, create a new node for it
    if (carry > 0) {
        temp = (struct node*)malloc(sizeof(struct node));
        temp->data = carry;
        temp->next = NULL;
        prev->next = temp;
    }

    return result;  // Return the head of the result list
}

11)Write an iterative Reverse() function that reverses a list by rearranging all the .next pointers and the head pointer. Ideally, Reverse() should only need to make one pass of the list. 
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a node
struct node {
    int data;
    struct node* next;
};

// Function prototypes
struct node* create(int n);
void display(struct node* head);
void reverse(struct node** head);

int main() {
    int n;
    struct node* head;

    // Ask for the number of nodes
    printf("Enter the number of nodes: ");
    scanf("%d", &n);

    // Create the linked list
    head = create(n);

    // Display the linked list
    printf("Original list: ");
    display(head);

    // Reverse the linked list
    reverse(&head);

    // Display the reversed linked list
    printf("Reversed list: ");
    display(head);

    return 0;
}

// Function to create a linked list with n nodes
struct node* create(int n) {
    int value, i;
    struct node *head, *p;

    // Create the first node
    printf("Enter the first node: ");
    scanf("%d", &value);

    head = (struct node*)malloc(sizeof(struct node));
    head->data = value;
    head->next = NULL;
    p = head;

    // Create the remaining nodes
    for (i = 1; i < n; i++) {
        p->next = (struct node*)malloc(sizeof(struct node));
        p = p->next;
        printf("Enter node %d: ", i + 1);
        scanf("%d", &p->data);
        p->next = NULL;
    }

    return head;  // Return the head of the linked list
}

// Function to display the linked list
void display(struct node* head) {
    struct node* p = head;

    // Traverse the list and print the data
    while (p != NULL) {
        printf("%d\t", p->data);
        p = p->next;
    }
    printf("\n");
}

// Function to reverse the linked list iteratively
void reverse(struct node** head) {
    struct node *prev = NULL, *current = *head, *next = NULL;

    // Traverse the list and reverse the links
    while (current != NULL) {
        next = current->next;  // Store the next node
        current->next = prev;  // Reverse the current node's pointer
        prev = current;        // Move prev and current one step forward
        current = next;
    }

    *head = prev;  // Update the head to the new first node
}

12)WAP to perform Multiplication o f two polynomials using singly linked list. 
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a node (representing a term in the polynomial)
struct node {
    int coeff;
    int exp;
    struct node* next;
};

// Function prototypes
struct node* create(int n);
void display(struct node* head);
struct node* multiplyPolynomials(struct node* poly1, struct node* poly2);
struct node* insertTerm(struct node* head, int coeff, int exp);
struct node* addTerm(struct node* head, int coeff, int exp);

int main() {
    int n1, n2;
    struct node *poly1, *poly2, *result;

    // Ask for the number of terms in both polynomials
    printf("Enter the number of terms in the first polynomial: ");
    scanf("%d", &n1);
    poly1 = create(n1);

    printf("Enter the number of terms in the second polynomial: ");
    scanf("%d", &n2);
    poly2 = create(n2);

    // Display the polynomials
    printf("First Polynomial: ");
    display(poly1);
    printf("Second Polynomial: ");
    display(poly2);

    // Multiply the polynomials
    result = multiplyPolynomials(poly1, poly2);

    // Display the result of multiplication
    printf("Resultant Polynomial: ");
    display(result);

    return 0;
}

// Function to create a polynomial linked list with n terms
struct node* create(int n) {
    int coeff, exp, i;
    struct node *head, *p;
    printf("Enter the terms (coefficient and exponent) of the polynomial:\n");

    // Create the first node
    printf("Enter coefficient and exponent for term 1: ");
    scanf("%d %d", &coeff, &exp);
    head = (struct node*)malloc(sizeof(struct node));
    head->coeff = coeff;
    head->exp = exp;
    head->next = NULL;
    p = head;

    // Create the remaining nodes
    for (i = 1; i < n; i++) {
        printf("Enter coefficient and exponent for term %d: ", i + 1);
        scanf("%d %d", &coeff, &exp);
        p->next = (struct node*)malloc(sizeof(struct node));
        p = p->next;
        p->coeff = coeff;
        p->exp = exp;
        p->next = NULL;
    }

    return head;  // Return the head of the polynomial list
}

// Function to display a polynomial
void display(struct node* head) {
    struct node* p = head;
    while (p != NULL) {
        printf("%dx^%d", p->coeff, p->exp);
        if (p->next != NULL)
            printf(" + ");
        p = p->next;
    }
    printf("\n");
}

// Function to multiply two polynomials
struct node* multiplyPolynomials(struct node* poly1, struct node* poly2) {
    struct node* result = NULL;
    struct node* temp1 = poly1;
    struct node* temp2;

    // Traverse each term in poly1
    while (temp1 != NULL) {
        temp2 = poly2;
        // Multiply the current term of poly1 with all terms of poly2
        while (temp2 != NULL) {
            int coeff = temp1->coeff * temp2->coeff;
            int exp = temp1->exp + temp2->exp;
            result = addTerm(result, coeff, exp);
            temp2 = temp2->next;
        }
        temp1 = temp1->next;
    }

    return result;
}

// Function to add a term to the result polynomial (combining terms with the same exponent)
struct node* addTerm(struct node* head, int coeff, int exp) {
    struct node* temp = head;
    struct node* prev = NULL;

    // If the list is empty, create the first node
    if (head == NULL) {
        return insertTerm(head, coeff, exp);
    }

    // Traverse the list to find the correct position
    while (temp != NULL && temp->exp > exp) {
        prev = temp;
        temp = temp->next;
    }

    // If the term with the same exponent exists, add the coefficients
    if (temp != NULL && temp->exp == exp) {
        temp->coeff += coeff;
    } else {
        // Otherwise, insert the new term
        if (prev == NULL) {
            return insertTerm(head, coeff, exp);
        } else {
            prev->next = insertTerm(temp, coeff, exp);
        }
    }

    return head;
}

// Function to insert a term at the correct position in the result list
struct node* insertTerm(struct node* head, int coeff, int exp) {
    struct node* newNode = (struct node*)malloc(sizeof(struct node));
    newNode->coeff = coeff;
    newNode->exp = exp;
    newNode->next = head;
    return newNode;
}

13)WAP to store at most 10 digit integer in a Singly linked list and perform arithmetic operations on it.
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a node in the singly linked list
struct node {
    int data;
    struct node* next;
};

// Function prototypes
struct node* create(int num);
void display(struct node* head);
struct node* addNumbers(struct node* num1, struct node* num2);
struct node* subtractNumbers(struct node* num1, struct node* num2);
struct node* multiplyByDigit(struct node* head, int digit);
int getNumber(struct node* head);

int main() {
    struct node* num1 = NULL;
    struct node* num2 = NULL;
    struct node* result = NULL;
    int num1Value, num2Value, digit;
    
    // Input two numbers (max 10 digits each)
    printf("Enter the first 10-digit number: ");
    scanf("%d", &num1Value);
    num1 = create(num1Value);

    printf("Enter the second 10-digit number: ");
    scanf("%d", &num2Value);
    num2 = create(num2Value);
    
    // Display the numbers
    printf("First Number: ");
    display(num1);
    printf("Second Number: ");
    display(num2);
    
    // Perform addition
    result = addNumbers(num1, num2);
    printf("Addition Result: ");
    display(result);
    
    // Perform subtraction
    result = subtractNumbers(num1, num2);
    printf("Subtraction Result: ");
    display(result);
    
    // Input a single digit to multiply by
    printf("Enter a digit to multiply the first number: ");
    scanf("%d", &digit);
    result = multiplyByDigit(num1, digit);
    printf("Multiplication Result: ");
    display(result);
    
    return 0;
}

// Function to create a linked list for the number
struct node* create(int num) {
    struct node* head = NULL;
    struct node* temp = NULL;
    struct node* p = NULL;

    while (num > 0) {
        temp = (struct node*)malloc(sizeof(struct node));
        temp->data = num % 10;
        temp->next = NULL;

        if (head == NULL) {
            head = temp;
            p = head;
        } else {
            p->next = temp;
            p = temp;
        }

        num /= 10;
    }

    return head; // Return the head of the linked list
}

// Function to display the number from the linked list
void display(struct node* head) {
    struct node* p = head;
    while (p != NULL) {
        printf("%d", p->data);
        p = p->next;
    }
    printf("\n");
}

// Function to add two numbers stored in linked lists
struct node* addNumbers(struct node* num1, struct node* num2) {
    struct node* result = NULL;
    struct node* temp = NULL;
    struct node* p = NULL;
    int carry = 0, sum;

    while (num1 != NULL || num2 != NULL || carry != 0) {
        sum = carry;
        if (num1 != NULL) {
            sum += num1->data;
            num1 = num1->next;
        }
        if (num2 != NULL) {
            sum += num2->data;
            num2 = num2->next;
        }

        carry = sum / 10;
        sum = sum % 10;

        temp = (struct node*)malloc(sizeof(struct node));
        temp->data = sum;
        temp->next = NULL;

        if (result == NULL) {
            result = temp;
            p = result;
        } else {
            p->next = temp;
            p = temp;
        }
    }

    return result;
}

// Function to subtract two numbers stored in linked lists
struct node* subtractNumbers(struct node* num1, struct node* num2) {
    struct node* result = NULL;
    struct node* temp = NULL;
    struct node* p = NULL;
    int borrow = 0, diff;

    while (num1 != NULL || num2 != NULL) {
        diff = borrow;
        if (num1 != NULL) {
            diff += num1->data;
            num1 = num1->next;
        }
        if (num2 != NULL) {
            diff -= num2->data;
            num2 = num2->next;
        }

        if (diff < 0) {
            diff += 10;
            borrow = 1;
        } else {
            borrow = 0;
        }

        temp = (struct node*)malloc(sizeof(struct node));
        temp->data = diff;
        temp->next = NULL;

        if (result == NULL) {
            result = temp;
            p = result;
        } else {
            p->next = temp;
            p = temp;
        }
    }

    return result;
}

// Function to multiply a number stored in the linked list by a single digit
struct node* multiplyByDigit(struct node* head, int digit) {
    struct node* result = NULL;
    struct node* temp = NULL;
    struct node* p = NULL;
    int carry = 0, product;

    while (head != NULL || carry != 0) {
        product = carry + (head ? head->data : 0) * digit;
        carry = product / 10;
        product = product % 10;

        temp = (struct node*)malloc(sizeof(struct node));
        temp->data = product;
        temp->next = NULL;

        if (result == NULL) {
            result = temp;
            p = result;
        } else {
            p->next = temp;
            p = temp;
        }

        if (head != NULL)
            head = head->next;
    }

    return result;
}

// Function to convert the linked list back into an integer (for debugging purposes)
int getNumber(struct node* head) {
    int num = 0;
    struct node* p = head;
    while (p != NULL) {
        num = num * 10 + p->data;
        p = p->next;
    }
    return num;
}

14)WAP to create doubly linked list and perform following operations on it. A) Insert (all cases) 2. Delete (all cases).
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a node in a doubly linked list
struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

// Function prototypes
void insertAtBeginning(struct Node** head, int data);
void insertAtEnd(struct Node** head, int data);
void insertAtPosition(struct Node** head, int data, int position);
void deleteAtBeginning(struct Node** head);
void deleteAtEnd(struct Node** head);
void deleteAtPosition(struct Node** head, int position);
void displayList(struct Node* head);

// Main function
int main() {
    struct Node* head = NULL;

    // Perform insertion at the beginning, end, and at a specific position
    insertAtBeginning(&head, 10);
    insertAtEnd(&head, 20);
    insertAtEnd(&head, 30);
    insertAtPosition(&head, 15, 2);  // Insert 15 at position 2

    // Display the list
    printf("Doubly Linked List after insertions: ");
    displayList(head);

    // Perform deletion at the beginning, end, and a specific position
    deleteAtBeginning(&head);  // Delete from the beginning
    deleteAtEnd(&head);        // Delete from the end
    deleteAtPosition(&head, 1);  // Delete at position 1

    // Display the list after deletions
    printf("\nDoubly Linked List after deletions: ");
    displayList(head);

    return 0;
}

// Function to insert a node at the beginning
void insertAtBeginning(struct Node** head, int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = *head;
    newNode->prev = NULL;

    if (*head != NULL) {
        (*head)->prev = newNode;
    }
    *head = newNode;
}

// Function to insert a node at the end
void insertAtEnd(struct Node** head, int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    struct Node* temp = *head;
    newNode->data = data;
    newNode->next = NULL;

    if (*head == NULL) {
        newNode->prev = NULL;
        *head = newNode;
        return;
    }

    while (temp->next != NULL) {
        temp = temp->next;
    }

    temp->next = newNode;
    newNode->prev = temp;
}

// Function to insert a node at a specific position
void insertAtPosition(struct Node** head, int data, int position) {
    if (position < 1) {
        printf("Invalid position\n");
        return;
    }

    if (position == 1) {
        insertAtBeginning(head, data);
        return;
    }

    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    struct Node* temp = *head;
    newNode->data = data;

    for (int i = 1; temp != NULL && i < position - 1; i++) {
        temp = temp->next;
    }

    if (temp == NULL) {
        printf("Position exceeds list length. Inserting at the end.\n");
        insertAtEnd(head, data);
        return;
    }

    newNode->next = temp->next;
    newNode->prev = temp;

    if (temp->next != NULL) {
        temp->next->prev = newNode;
    }
    temp->next = newNode;
}

// Function to delete a node from the beginning
void deleteAtBeginning(struct Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node* temp = *head;
    *head = (*head)->next;

    if (*head != NULL) {
        (*head)->prev = NULL;
    }

    free(temp);
}

// Function to delete a node from the end
void deleteAtEnd(struct Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node* temp = *head;
    while (temp->next != NULL) {
        temp = temp->next;
    }

    if (temp->prev != NULL) {
        temp->prev->next = NULL;
    } else {
        *head = NULL;  // If there is only one node
    }

    free(temp);
}

// Function to delete a node at a specific position
void deleteAtPosition(struct Node** head, int position) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    if (position < 1) {
        printf("Invalid position\n");
        return;
    }

    struct Node* temp = *head;

    // Deleting at the beginning
    if (position == 1) {
        deleteAtBeginning(head);
        return;
    }

    for (int i = 1; temp != NULL && i < position; i++) {
        temp = temp->next;
    }

    if (temp == NULL) {
        printf("Position exceeds list length\n");
        return;
    }

    // If the node to be deleted is not the last node
    if (temp->next != NULL) {
        temp->next->prev = temp->prev;
    }

    if (temp->prev != NULL) {
        temp->prev->next = temp->next;
    }

    free(temp);
}

// Function to display the list
void displayList(struct Node* head) {
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}
15)WAP to store at most 10 digit integer in a Doubly linked list and perform arithmetic operations on it. 
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a doubly linked list node
struct Node {
    int data;               // To store a digit
    struct Node* next;      // Pointer to next node
    struct Node* prev;      // Pointer to previous node
};

// Function prototypes
void insertEnd(struct Node** head, int data);
void displayList(struct Node* head);
struct Node* addTwoNumbers(struct Node* list1, struct Node* list2);

int main() {
    struct Node* head1 = NULL;
    struct Node* head2 = NULL;
    int num1, num2;

    // Input two 10-digit numbers
    printf("Enter the first 10-digit number: ");
    scanf("%d", &num1);
    printf("Enter the second 10-digit number: ");
    scanf("%d", &num2);

    // Insert digits of the first number into the list
    while (num1 > 0) {
        insertEnd(&head1, num1 % 10);
        num1 /= 10;
    }

    // Insert digits of the second number into the list
    while (num2 > 0) {
        insertEnd(&head2, num2 % 10);
        num2 /= 10;
    }

    // Display the two numbers
    printf("First number: ");
    displayList(head1);
    printf("Second number: ");
    displayList(head2);

    // Add the two numbers
    struct Node* result = addTwoNumbers(head1, head2);

    // Display the result
    printf("Sum: ");
    displayList(result);

    return 0;
}

// Function to insert a digit at the end of the doubly linked list
void insertEnd(struct Node** head, int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;

    if (*head == NULL) {
        *head = newNode;
    } else {
        struct Node* temp = *head;
        while (temp->next != NULL) {
            temp = temp->next;
        }
        temp->next = newNode;
        newNode->prev = temp;
    }
}

// Function to display the doubly linked list (from head to tail)
void displayList(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

// Function to add two numbers represented as doubly linked lists
struct Node* addTwoNumbers(struct Node* list1, struct Node* list2) {
    struct Node* result = NULL;
    struct Node* temp1 = list1;
    struct Node* temp2 = list2;
    struct Node* tempResult = NULL;
    int carry = 0;

    // Traverse both lists and perform addition
    while (temp1 != NULL || temp2 != NULL || carry != 0) {
        int sum = carry;

        if (temp1 != NULL) {
            sum += temp1->data;
            temp1 = temp1->next;
        }

        if (temp2 != NULL) {
            sum += temp2->data;
            temp2 = temp2->next;
        }

        carry = sum / 10;  // Calculate carry for next iteration
        sum = sum % 10;    // Store the current digit

        insertEnd(&result, sum);  // Insert the current digit to the result
    }

    return result;
}

16)WAP to merge two sorted Doubly linked lists and display ther result.
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a doubly linked list node
struct Node {
    int data;               // To store a digit or value
    struct Node* next;      // Pointer to next node
    struct Node* prev;      // Pointer to previous node
};

// Function prototypes
void insertEnd(struct Node** head, int data);
void displayList(struct Node* head);
struct Node* mergeSortedLists(struct Node* list1, struct Node* list2);

int main() {
    struct Node* head1 = NULL;
    struct Node* head2 = NULL;

    // Insert elements into the first sorted list
    insertEnd(&head1, 1);
    insertEnd(&head1, 3);
    insertEnd(&head1, 5);
    insertEnd(&head1, 7);

    // Insert elements into the second sorted list
    insertEnd(&head2, 2);
    insertEnd(&head2, 4);
    insertEnd(&head2, 6);
    insertEnd(&head2, 8);

    // Display the original sorted lists
    printf("First sorted list: ");
    displayList(head1);

    printf("Second sorted list: ");
    displayList(head2);

    // Merge the two sorted lists
    struct Node* mergedHead = mergeSortedLists(head1, head2);

    // Display the merged sorted list
    printf("Merged sorted list: ");
    displayList(mergedHead);

    return 0;
}

// Function to insert a new node with 'data' at the end of the doubly linked list
void insertEnd(struct Node** head, int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    struct Node* temp = *head;

    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;

    // If the list is empty, the new node becomes the head
    if (*head == NULL) {
        *head = newNode;
        return;
    }

    // Otherwise, traverse to the end and insert the new node
    while (temp->next != NULL) {
        temp = temp->next;
    }

    temp->next = newNode;
    newNode->prev = temp;
}

// Function to display the doubly linked list
void displayList(struct Node* head) {
    struct Node* temp = head;

    // Traverse the list and print the data
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

// Function to merge two sorted doubly linked lists into a single sorted list
struct Node* mergeSortedLists(struct Node* list1, struct Node* list2) {
    // If one of the lists is empty, return the other list
    if (list1 == NULL) return list2;
    if (list2 == NULL) return list1;

    // Create a dummy node to start the merged list
    struct Node* mergedHead = NULL;
    struct Node* mergedTail = NULL;

    // Traverse both lists and merge them in sorted order
    while (list1 != NULL && list2 != NULL) {
        struct Node* temp = NULL;

        // Compare the data of the nodes from both lists
        if (list1->data <= list2->data) {
            temp = list1;
            list1 = list1->next;
        } else {
            temp = list2;
            list2 = list2->next;
        }

        // If merged list is empty, initialize the merged head and tail
        if (mergedHead == NULL) {
            mergedHead = temp;
            mergedTail = temp;
        } else {
            // Otherwise, attach the selected node to the merged list
            mergedTail->next = temp;
            temp->prev = mergedTail;
            mergedTail = temp;
        }
    }

    // If one of the lists is not empty, append the rest of it to the merged list
    if (list1 != NULL) {
        mergedTail->next = list1;
        list1->prev = mergedTail;
    }
    if (list2 != NULL) {
        mergedTail->next = list2;
        list2->prev = mergedTail;
    }

    return mergedHead;
}
17)Implement Push and POP operations of STACK on Doubly linked lists
#include <stdio.h>
#include <stdlib.h>

// Define the structure for the doubly linked list node
struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

// Function prototypes
void push(struct Node** top, int data);
int pop(struct Node** top);
void display(struct Node* top);

int main() {
    struct Node* stack = NULL;  // Initialize the stack as an empty stack

    // Push elements onto the stack
    push(&stack, 10);
    push(&stack, 20);
    push(&stack, 30);
    push(&stack, 40);

    // Display the stack
    printf("Stack after push operations:\n");
    display(stack);

    // POP elements from the stack
    printf("\nPopped element: %d\n", pop(&stack));
    printf("Popped element: %d\n", pop(&stack));

    // Display the stack after POP operations
    printf("\nStack after pop operations:\n");
    display(stack);

    return 0;
}

// Function to push an element onto the stack
void push(struct Node** top, int data) {
    // Allocate memory for the new node
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = *top;  // Make next of new node as the current top of stack
    newNode->prev = NULL;  // New node becomes the top, so its previous is NULL

    // If the stack is not empty, update the previous pointer of the old top node
    if (*top != NULL) {
        (*top)->prev = newNode;
    }

    // Move the top pointer to point to the new node
    *top = newNode;
}

// Function to pop an element from the stack
int pop(struct Node** top) {
    // Check if the stack is empty
    if (*top == NULL) {
        printf("Stack is empty, cannot pop.\n");
        return -1;  // Return an invalid value to indicate empty stack
    }

    // Store the data to return later
    int poppedData = (*top)->data;
    
    // Move the top pointer to the next node
    struct Node* temp = *top;
    *top = (*top)->next;

    // If the new top exists, set its previous pointer to NULL
    if (*top != NULL) {
        (*top)->prev = NULL;
    }

    // Free the memory of the old top node
    free(temp);

    return poppedData;  // Return the data of the popped node
}

// Function to display the stack
void display(struct Node* top) {
    if (top == NULL) {
        printf("Stack is empty.\n");
        return;
    }

    // Traverse the stack and print all elements
    struct Node* temp = top;
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

18)Implement ADD and DELETE operations of QUEUE on Doubly linked lists
#include <stdio.h>
#include <stdlib.h>

// Define the structure for the doubly linked list node
struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

// Function prototypes
void enqueue(struct Node** front, struct Node** rear, int data);
int dequeue(struct Node** front, struct Node** rear);
void display(struct Node* front);

int main() {
    struct Node* front = NULL;
    struct Node* rear = NULL;

    // Enqueue elements into the queue
    enqueue(&front, &rear, 10);
    enqueue(&front, &rear, 20);
    enqueue(&front, &rear, 30);
    enqueue(&front, &rear, 40);

    // Display the queue
    printf("Queue after enqueue operations:\n");
    display(front);

    // Dequeue elements from the queue
    printf("\nDequeued element: %d\n", dequeue(&front, &rear));
    printf("Dequeued element: %d\n", dequeue(&front, &rear));

    // Display the queue after dequeues
    printf("\nQueue after dequeue operations:\n");
    display(front);

    return 0;
}

// Function to add an element to the queue (enqueue)
void enqueue(struct Node** front, struct Node** rear, int data) {
    // Create a new node
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = *rear;

    // If the queue is empty, both front and rear will point to the new node
    if (*rear == NULL) {
        *front = *rear = newNode;
    } else {
        // Otherwise, link the new node to the end of the queue
        (*rear)->next = newNode;
        *rear = newNode;
    }
}

// Function to remove an element from the queue (dequeue)
int dequeue(struct Node** front, struct Node** rear) {
    // Check if the queue is empty
    if (*front == NULL) {
        printf("Queue is empty, cannot dequeue.\n");
        return -1; // Return an invalid value to indicate empty queue
    }

    // Store the data of the node to return later
    int dequeuedData = (*front)->data;
    struct Node* temp = *front;

    // Move the front pointer to the next node
    *front = (*front)->next;

    // If the front becomes NULL, the queue is empty, so set the rear to NULL
    if (*front == NULL) {
        *rear = NULL;
    } else {
        // Otherwise, update the previous pointer of the new front node to NULL
        (*front)->prev = NULL;
    }

    // Free the memory of the old front node
    free(temp);

    return dequeuedData;
}

// Function to display the queue
void display(struct Node* front) {
    if (front == NULL) {
        printf("Queue is empty.\n");
        return;
    }

    // Traverse the queue and print all elements
    struct Node* temp = front;
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

19) Implement Insertion sort using Singly Linked List
#include <stdio.h>
#include <stdlib.h>

// Define the structure for the singly linked list node
struct Node {
    int data;
    struct Node* next;
};

// Function prototypes
void insertSorted(struct Node** head, int data);
void insertionSort(struct Node** head);
void display(struct Node* head);
struct Node* createNode(int data);

int main() {
    struct Node* head = NULL;
    
    // Insert nodes into the list
    insertSorted(&head, 30);
    insertSorted(&head, 10);
    insertSorted(&head, 50);
    insertSorted(&head, 20);
    insertSorted(&head, 40);
    
    // Display the list before sorting
    printf("Original List: ");
    display(head);

    // Sort the list using insertion sort
    insertionSort(&head);

    // Display the list after sorting
    printf("Sorted List: ");
    display(head);

    return 0;
}

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a new node at the beginning of the list
void insertSorted(struct Node** head, int data) {
    struct Node* newNode = createNode(data);
    
    // Insert the node at the front
    newNode->next = *head;
    *head = newNode;
}

// Function to perform Insertion Sort on the linked list
void insertionSort(struct Node** head) {
    struct Node *sorted = NULL; // Start with an empty sorted list
    struct Node *current = *head; // Traverse the given list
    
    while (current != NULL) {
        struct Node* next = current->next; // Store next node
        // Insert current node in the sorted list
        insertSorted(&sorted, current->data);
        current = next; // Move to the next node in the original list
    }
    
    // Update the head of the original list to point to the sorted list
    *head = sorted;
}

// Function to display the linked list
void display(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

20)Implement Bubble sort using Doubly Linked List
#include <stdio.h>
#include <stdlib.h>

// Define the structure for the doubly linked list node
struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

// Function prototypes
void append(struct Node** head, int data);
void display(struct Node* head);
void bubbleSort(struct Node* head);
void swap(struct Node* a, struct Node* b);

int main() {
    struct Node* head = NULL;
    
    // Adding nodes to the doubly linked list
    append(&head, 30);
    append(&head, 10);
    append(&head, 50);
    append(&head, 20);
    append(&head, 40);
    
    // Display the list before sorting
    printf("Original List: ");
    display(head);
    
    // Perform Bubble Sort
    bubbleSort(head);
    
    // Display the list after sorting
    printf("Sorted List: ");
    display(head);

    return 0;
}

// Function to append a new node at the end of the doubly linked list
void append(struct Node** head, int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    struct Node* last = *head;
    
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
    
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    
    while (last->next != NULL) {
        last = last->next;
    }
    
    last->next = newNode;
    newNode->prev = last;
}

// Function to display the elements of the doubly linked list
void display(struct Node* head) {
    struct Node* temp = head;
    
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

// Function to perform Bubble Sort on the doubly linked list
void bubbleSort(struct Node* head) {
    int swapped;
    struct Node* ptr1;
    struct Node* ptr2 = NULL;
    
    // If the list is empty or has only one element, no sorting is needed
    if (head == NULL) {
        return;
    }
    
    do {
        swapped = 0;
        ptr1 = head;
        
        // Traverse the list from head to the second last element
        while (ptr1->next != ptr2) {
            if (ptr1->data > ptr1->next->data) {
                // Swap the data of the nodes
                swap(ptr1, ptr1->next);
                swapped = 1;
            }
            ptr1 = ptr1->next;
        }
        
        // Set the last node as sorted
        ptr2 = ptr1;
        
    } while (swapped); // Continue the process until no swap is needed
}

// Function to swap the data of two nodes
void swap(struct Node* a, struct Node* b) {
    int temp = a->data;
    a->data = b->data;
    b->data = temp;
}

21)Write a Program to create a Binary Tree and perform following nonrecursive operations on it. a. Preorder Traversal b. Postorder Traversal c. Count total no. of nodes d. Display height of a tree.
#include <stdio.h>
#include <stdlib.h>
#include <stack>

// Define the structure for the binary tree node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function prototypes
struct Node* createNode(int data);
void insert(struct Node** root, int data);
void preorderTraversal(struct Node* root);
void postorderTraversal(struct Node* root);
int countNodes(struct Node* root);
int heightOfTree(struct Node* root);

int main() {
    struct Node* root = NULL;

    // Insert nodes into the binary tree
    insert(&root, 10);
    insert(&root, 5);
    insert(&root, 15);
    insert(&root, 2);
    insert(&root, 7);
    insert(&root, 12);
    insert(&root, 20);

    printf("Preorder Traversal: ");
    preorderTraversal(root);
    printf("\n");

    printf("Postorder Traversal: ");
    postorderTraversal(root);
    printf("\n");

    printf("Total number of nodes: %d\n", countNodes(root));

    printf("Height of the tree: %d\n", heightOfTree(root));

    return 0;
}

// Function to create a new binary tree node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to insert a node in the binary tree (simplified)
void insert(struct Node** root, int data) {
    struct Node* newNode = createNode(data);
    if (*root == NULL) {
        *root = newNode;
        return;
    }

    struct Node* temp = *root;
    while (temp != NULL) {
        if (data < temp->data) {
            if (temp->left == NULL) {
                temp->left = newNode;
                break;
            }
            temp = temp->left;
        } else {
            if (temp->right == NULL) {
                temp->right = newNode;
                break;
            }
            temp = temp->right;
        }
    }
}

// Non-recursive Preorder Traversal (using stack)
void preorderTraversal(struct Node* root) {
    if (root == NULL) return;

    std::stack<struct Node*> stack;
    stack.push(root);

    while (!stack.empty()) {
        struct Node* node = stack.top();
        stack.pop();
        printf("%d ", node->data);

        if (node->right != NULL) {
            stack.push(node->right);
        }
        if (node->left != NULL) {
            stack.push(node->left);
        }
    }
}

// Non-recursive Postorder Traversal (using stack)
void postorderTraversal(struct Node* root) {
    if (root == NULL) return;

    std::stack<struct Node*> stack;
    std::stack<int> output;
    stack.push(root);

    while (!stack.empty()) {
        struct Node* node = stack.top();
        stack.pop();
        output.push(node->data);

        if (node->left != NULL) {
            stack.push(node->left);
        }
        if (node->right != NULL) {
            stack.push(node->right);
        }
    }

    // Print the postorder traversal
    while (!output.empty()) {
        printf("%d ", output.top());
        output.pop();
    }
}

// Function to count the total number of nodes
int countNodes(struct Node* root) {
    if (root == NULL) return 0;

    int count = 0;
    std::stack<struct Node*> stack;
    stack.push(root);

    while (!stack.empty()) {
        struct Node* node = stack.top();
        stack.pop();
        count++;

        if (node->right != NULL) {
            stack.push(node->right);
        }
        if (node->left != NULL) {
            stack.push(node->left);
        }
    }

    return count;
}

// Function to find the height of the tree
int heightOfTree(struct Node* root) {
    if (root == NULL) return -1;

    int height = -1;
    std::stack<std::pair<struct Node*, int>> stack;
    stack.push({root, 0});

    while (!stack.empty()) {
        struct Node* node = stack.top().first;
        int depth = stack.top().second;
        stack.pop();

        height = (depth > height) ? depth : height;

        if (node->left != NULL) {
            stack.push({node->left, depth + 1});
        }
        if (node->right != NULL) {
            stack.push({node->right, depth + 1});
        }
    }

    return height;
}

22)Write a Program to create a Binary Tree and perform following nonrecursive operations on it. a. Levelwise display b. Mirror image c. Display height of a tree.
#include <stdio.h>
#include <stdlib.h>
#include <queue>

// Define the structure for the binary tree node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function prototypes
struct Node* createNode(int data);
void insert(struct Node** root, int data);
void levelwiseDisplay(struct Node* root);
void mirrorImage(struct Node* root);
int heightOfTree(struct Node* root);

int main() {
    struct Node* root = NULL;

    // Insert nodes into the binary tree
    insert(&root, 10);
    insert(&root, 5);
    insert(&root, 15);
    insert(&root, 2);
    insert(&root, 7);
    insert(&root, 12);
    insert(&root, 20);

    printf("Levelwise Display: \n");
    levelwiseDisplay(root);
    printf("\n");

    printf("Mirror Image of the Tree: \n");
    mirrorImage(root);
    levelwiseDisplay(root);
    printf("\n");

    printf("Height of the Tree: %d\n", heightOfTree(root));

    return 0;
}

// Function to create a new binary tree node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to insert a node in the binary tree (simplified)
void insert(struct Node** root, int data) {
    struct Node* newNode = createNode(data);
    if (*root == NULL) {
        *root = newNode;
        return;
    }

    struct Node* temp = *root;
    while (temp != NULL) {
        if (data < temp->data) {
            if (temp->left == NULL) {
                temp->left = newNode;
                break;
            }
            temp = temp->left;
        } else {
            if (temp->right == NULL) {
                temp->right = newNode;
                break;
            }
            temp = temp->right;
        }
    }
}

// Function for Levelwise Display (Level Order Traversal)
void levelwiseDisplay(struct Node* root) {
    if (root == NULL) return;

    std::queue<struct Node*> q;
    q.push(root);

    while (!q.empty()) {
        struct Node* node = q.front();
        q.pop();
        printf("%d ", node->data);

        if (node->left != NULL) {
            q.push(node->left);
        }
        if (node->right != NULL) {
            q.push(node->right);
        }
    }
}

// Function to create the Mirror Image of the tree
void mirrorImage(struct Node* root) {
    if (root == NULL) return;

    // Swap the left and right children of the node
    struct Node* temp;
    temp = root->left;
    root->left = root->right;
    root->right = temp;

    // Recursively create the mirror image for left and right subtrees
    mirrorImage(root->left);
    mirrorImage(root->right);
}

// Function to calculate the height of the tree
int heightOfTree(struct Node* root) {
    if (root == NULL) return -1;

    int height = -1;
    std::queue<std::pair<struct Node*, int>> q;
    q.push({root, 0});

    while (!q.empty()) {
        struct Node* node = q.front().first;
        int depth = q.front().second;
        q.pop();

        height = (depth > height) ? depth : height;

        if (node->left != NULL) {
            q.push({node->left, depth + 1});
        }
        if (node->right != NULL) {
            q.push({node->right, depth + 1});
        }
    }

    return height;
}

22)Write a program to illustrate operations on a BST holding numeric keys. The menu must include: â€¢ Insert â€¢ Delete â€¢ Find â€¢ Show
#include <stdio.h>
#include <stdlib.h>

// Define the structure for the binary search tree node
struct Node {
    int key;
    struct Node *left, *right;
};

// Function prototypes
struct Node* createNode(int key);
struct Node* insert(struct Node* root, int key);
struct Node* deleteNode(struct Node* root, int key);
struct Node* findMin(struct Node* root);
struct Node* find(struct Node* root, int key);
void inorder(struct Node* root);

int main() {
    struct Node* root = NULL;

    // Insert nodes into the BST
    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 70);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 60);
    root = insert(root, 80);

    // Show the tree using Inorder Traversal
    printf("Inorder traversal of the tree: ");
    inorder(root);
    printf("\n");

    // Find a node
    int keyToFind = 30;
    struct Node* foundNode = find(root, keyToFind);
    if (foundNode != NULL) {
        printf("Node with key %d found.\n", keyToFind);
    } else {
        printf("Node with key %d not found.\n", keyToFind);
    }

    // Delete a node
    int keyToDelete = 30;
    root = deleteNode(root, keyToDelete);
    printf("After deleting key %d, Inorder traversal of the tree: ", keyToDelete);
    inorder(root);
    printf("\n");

    return 0;
}

// Function to create a new node
struct Node* createNode(int key) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node into the BST
struct Node* insert(struct Node* root, int key) {
    if (root == NULL) {
        return createNode(key);
    }
    if (key < root->key) {
        root->left = insert(root->left, key);
    } else if (key > root->key) {
        root->right = insert(root->right, key);
    }
    return root;
}

// Function to find the minimum node in the BST (used for deletion)
struct Node* findMin(struct Node* root) {
    while (root->left != NULL) {
        root = root->left;
    }
    return root;
}

// Function to delete a node from the BST
struct Node* deleteNode(struct Node* root, int key) {
    if (root == NULL) {
        return root;
    }

    // Find the node to delete
    if (key < root->key) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->key) {
        root->right = deleteNode(root->right, key);
    } else {
        // Node to be deleted is found

        // Case 1: Node has no children (leaf node)
        if (root->left == NULL && root->right == NULL) {
            free(root);
            return NULL;
        }

        // Case 2: Node has one child
        if (root->left == NULL) {
            struct Node* temp = root->right;
            free(root);
            return temp;
        }
        if (root->right == NULL) {
            struct Node* temp = root->left;
            free(root);
            return temp;
        }

        // Case 3: Node has two children
        struct Node* temp = findMin(root->right); // Get the inorder successor
        root->key = temp->key; // Copy the inorder successor's content to this node
        root->right = deleteNode(root->right, temp->key); // Delete the inorder successor
    }
    return root;
}

// Function to find a node in the BST
struct Node* find(struct Node* root, int key) {
    if (root == NULL || root->key == key) {
        return root;
    }
    if (key < root->key) {
        return find(root->left, key);
    }
    return find(root->right, key);
}

// Function for inorder traversal of the BST (Show)
void inorder(struct Node* root) {
    if (root == NULL) {
        return;
    }
    inorder(root->left);
    printf("%d ", root->key);
    inorder(root->right);
}

23)Write a program to illustrate operations on a BST holding numeric keys. The menu must include: â€¢ Insert â€¢ Mirror Image â€¢ Find â€¢ Post order (nonrecursive)
#include <stdio.h>
#include <stdlib.h>
#include <stack>

// Define the structure for the binary search tree node
struct Node {
    int key;
    struct Node *left, *right;
};

// Function prototypes
struct Node* createNode(int key);
struct Node* insert(struct Node* root, int key);
struct Node* find(struct Node* root, int key);
void postorderNonRecursive(struct Node* root);
struct Node* mirror(struct Node* root);
void inorder(struct Node* root);

int main() {
    struct Node* root = NULL;
    int key;

    // Insert nodes into the BST
    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);

    // Display In-order traversal for verification
    printf("In-order traversal: ");
    inorder(root);
    printf("\n");

    // Perform mirror operation
    root = mirror(root);
    printf("In-order traversal of mirror image: ");
    inorder(root);
    printf("\n");

    // Find a key in the tree
    key = 40;
    struct Node* foundNode = find(root, key);
    if (foundNode != NULL) {
        printf("Node with key %d found.\n", key);
    } else {
        printf("Node with key %d not found.\n", key);
    }

    // Perform post-order traversal (non-recursive)
    printf("Post-order traversal (Non-recursive): ");
    postorderNonRecursive(root);
    printf("\n");

    return 0;
}

// Function to create a new node
struct Node* createNode(int key) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node into the BST
struct Node* insert(struct Node* root, int key) {
    if (root == NULL) {
        return createNode(key);
    }
    if (key < root->key) {
        root->left = insert(root->left, key);
    } else if (key > root->key) {
        root->right = insert(root->right, key);
    }
    return root;
}

// Function to find a node in the BST
struct Node* find(struct Node* root, int key) {
    if (root == NULL || root->key == key) {
        return root;
    }
    if (key < root->key) {
        return find(root->left, key);
    }
    return find(root->right, key);
}

// Function to display the BST in In-order (for verification purposes)
void inorder(struct Node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->key);
        inorder(root->right);
    }
}

// Non-recursive Post-order traversal (left-right-root)
void postorderNonRecursive(struct Node* root) {
    if (root == NULL) return;

    std::stack<struct Node*> s1, s2;
    s1.push(root);

    while (!s1.empty()) {
        struct Node* curr = s1.top();
        s1.pop();
        s2.push(curr);

        if (curr->left) {
            s1.push(curr->left);
        }
        if (curr->right) {
            s1.push(curr->right);
        }
    }

    while (!s2.empty()) {
        struct Node* curr = s2.top();
        printf("%d ", curr->key);
        s2.pop();
    }
}

// Function to create the mirror image of the tree
struct Node* mirror(struct Node* root) {
    if (root == NULL) {
        return NULL;
    }

    struct Node* temp = root->left;
    root->left = mirror(root->right);
    root->right = mirror(temp);

    return root;
}


24)Write a Program to create a Binary Tree and perform following Nonrecursive operations on it. a. Inorder Traversal b. Preorder Traversal c. Display Number of Leaf Nodes d. Mirror Image
#include <stdio.h>
#include <stdlib.h>
#include <stack>

// Define the structure for the binary tree node
struct Node {
    int key;
    struct Node *left, *right;
};

// Function prototypes
struct Node* createNode(int key);
struct Node* insert(struct Node* root, int key);
void inorderNonRecursive(struct Node* root);
void preorderNonRecursive(struct Node* root);
int countLeafNodes(struct Node* root);
struct Node* mirror(struct Node* root);

int main() {
    struct Node* root = NULL;

    // Insert nodes into the tree
    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);

    // In-order traversal (non-recursive)
    printf("In-order traversal (Non-recursive): ");
    inorderNonRecursive(root);
    printf("\n");

    // Pre-order traversal (non-recursive)
    printf("Pre-order traversal (Non-recursive): ");
    preorderNonRecursive(root);
    printf("\n");

    // Count leaf nodes
    int leafCount = countLeafNodes(root);
    printf("Number of leaf nodes: %d\n", leafCount);

    // Perform mirror operation
    root = mirror(root);
    printf("In-order traversal of mirror image (Non-recursive): ");
    inorderNonRecursive(root);
    printf("\n");

    return 0;
}

// Function to create a new node
struct Node* createNode(int key) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node into the binary search tree
struct Node* insert(struct Node* root, int key) {
    if (root == NULL) {
        return createNode(key);
    }
    if (key < root->key) {
        root->left = insert(root->left, key);
    } else if (key > root->key) {
        root->right = insert(root->right, key);
    }
    return root;
}

// Non-recursive In-order traversal (left-root-right)
void inorderNonRecursive(struct Node* root) {
    if (root == NULL) return;

    std::stack<struct Node*> stack;
    struct Node* current = root;

    while (current != NULL || !stack.empty()) {
        while (current != NULL) {
            stack.push(current);
            current = current->left;
        }

        current = stack.top();
        stack.pop();
        printf("%d ", current->key);
        current = current->right;
    }
}

// Non-recursive Pre-order traversal (root-left-right)
void preorderNonRecursive(struct Node* root) {
    if (root == NULL) return;

    std::stack<struct Node*> stack;
    stack.push(root);

    while (!stack.empty()) {
        struct Node* current = stack.top();
        stack.pop();
        printf("%d ", current->key);

        // Push right node first so left node is processed first
        if (current->right != NULL) {
            stack.push(current->right);
        }
        if (current->left != NULL) {
            stack.push(current->left);
        }
    }
}

// Function to count the number of leaf nodes
int countLeafNodes(struct Node* root) {
    if (root == NULL) return 0;

    std::stack<struct Node*> stack;
    stack.push(root);
    int leafCount = 0;

    while (!stack.empty()) {
        struct Node* current = stack.top();
        stack.pop();

        // If it's a leaf node, increment the count
        if (current->left == NULL && current->right == NULL) {
            leafCount++;
        }

        if (current->right != NULL) {
            stack.push(current->right);
        }
        if (current->left != NULL) {
            stack.push(current->left);
        }
    }

    return leafCount;
}

// Function to create the mirror image of the tree
struct Node* mirror(struct Node* root) {
    if (root == NULL) {
        return NULL;
    }

    struct Node* temp = root->left;
    root->left = mirror(root->right);
    root->right = mirror(temp);

    return root;
}

25)Write a Program to create a Binary Search Tree and perform following nonrecursive operations on it. a. Preorder Traversal b. Inorder Traversal c. Display Number of Leaf Nodes d. Mirror Image 
#include <stdio.h>
#include <stdlib.h>
#include <stack>

// Define the structure for the binary tree node
struct Node {
    int key;
    struct Node *left, *right;
};

// Function prototypes
struct Node* createNode(int key);
struct Node* insert(struct Node* root, int key);
void preorderNonRecursive(struct Node* root);
void inorderNonRecursive(struct Node* root);
int countLeafNodes(struct Node* root);
struct Node* mirror(struct Node* root);

int main() {
    struct Node* root = NULL;

    // Insert nodes into the tree
    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);

    // Pre-order traversal (non-recursive)
    printf("Pre-order traversal (Non-recursive): ");
    preorderNonRecursive(root);
    printf("\n");

    // In-order traversal (non-recursive)
    printf("In-order traversal (Non-recursive): ");
    inorderNonRecursive(root);
    printf("\n");

    // Count leaf nodes
    int leafCount = countLeafNodes(root);
    printf("Number of leaf nodes: %d\n", leafCount);

    // Perform mirror operation
    root = mirror(root);
    printf("In-order traversal of mirror image (Non-recursive): ");
    inorderNonRecursive(root);
    printf("\n");

    return 0;
}

// Function to create a new node
struct Node* createNode(int key) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node into the binary search tree
struct Node* insert(struct Node* root, int key) {
    if (root == NULL) {
        return createNode(key);
    }
    if (key < root->key) {
        root->left = insert(root->left, key);
    } else if (key > root->key) {
        root->right = insert(root->right, key);
    }
    return root;
}

// Non-recursive Pre-order traversal (root-left-right)
void preorderNonRecursive(struct Node* root) {
    if (root == NULL) return;

    std::stack<struct Node*> stack;
    stack.push(root);

    while (!stack.empty()) {
        struct Node* current = stack.top();
        stack.pop();
        printf("%d ", current->key);

        // Push right node first so left node is processed first
        if (current->right != NULL) {
            stack.push(current->right);
        }
        if (current->left != NULL) {
            stack.push(current->left);
        }
    }
}

// Non-recursive In-order traversal (left-root-right)
void inorderNonRecursive(struct Node* root) {
    if (root == NULL) return;

    std::stack<struct Node*> stack;
    struct Node* current = root;

    while (current != NULL || !stack.empty()) {
        while (current != NULL) {
            stack.push(current);
            current = current->left;
        }

        current = stack.top();
        stack.pop();
        printf("%d ", current->key);
        current = current->right;
    }
}

// Function to count the number of leaf nodes
int countLeafNodes(struct Node* root) {
    if (root == NULL) return 0;

    std::stack<struct Node*> stack;
    stack.push(root);
    int leafCount = 0;

    while (!stack.empty()) {
        struct Node* current = stack.top();
        stack.pop();

        // If it's a leaf node, increment the count
        if (current->left == NULL && current->right == NULL) {
            leafCount++;
        }

        if (current->right != NULL) {
            stack.push(current->right);
        }
        if (current->left != NULL) {
            stack.push(current->left);
        }
    }

    return leafCount;
}

// Function to create the mirror image of the tree
struct Node* mirror(struct Node* root) {
    if (root == NULL) {
        return NULL;
    }

    struct Node* temp = root->left;
    root->left = mirror(root->right);
    root->right = mirror(temp);

    return root;
}

25)Write a Program to create a Binary Search Tree and perform following nonrecursive operations on it. a. Preorder Traversal b. Postorder Traversal c. Display total Number of Nodes d. Display Leaf nodes.
#include <stdio.h>
#include <stdlib.h>
#include <stack>

// Define the structure for the binary tree node
struct Node {
    int key;
    struct Node *left, *right;
};

// Function prototypes
struct Node* createNode(int key);
struct Node* insert(struct Node* root, int key);
void preorderNonRecursive(struct Node* root);
void postorderNonRecursive(struct Node* root);
int countNodes(struct Node* root);
void displayLeafNodes(struct Node* root);

int main() {
    struct Node* root = NULL;

    // Insert nodes into the tree
    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);

    // Pre-order traversal (non-recursive)
    printf("Pre-order traversal (Non-recursive): ");
    preorderNonRecursive(root);
    printf("\n");

    // Post-order traversal (non-recursive)
    printf("Post-order traversal (Non-recursive): ");
    postorderNonRecursive(root);
    printf("\n");

    // Display total number of nodes
    int totalNodes = countNodes(root);
    printf("Total number of nodes: %d\n", totalNodes);

    // Display leaf nodes
    printf("Leaf nodes: ");
    displayLeafNodes(root);
    printf("\n");

    return 0;
}

// Function to create a new node
struct Node* createNode(int key) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node into the binary search tree
struct Node* insert(struct Node* root, int key) {
    if (root == NULL) {
        return createNode(key);
    }
    if (key < root->key) {
        root->left = insert(root->left, key);
    } else if (key > root->key) {
        root->right = insert(root->right, key);
    }
    return root;
}

// Non-recursive Pre-order traversal (root-left-right)
void preorderNonRecursive(struct Node* root) {
    if (root == NULL) return;

    std::stack<struct Node*> stack;
    stack.push(root);

    while (!stack.empty()) {
        struct Node* current = stack.top();
        stack.pop();
        printf("%d ", current->key);

        // Push right node first so left node is processed first
        if (current->right != NULL) {
            stack.push(current->right);
        }
        if (current->left != NULL) {
            stack.push(current->left);
        }
    }
}

// Non-recursive Post-order traversal (left-right-root)
void postorderNonRecursive(struct Node* root) {
    if (root == NULL) return;

    std::stack<struct Node*> stack1, stack2;
    stack1.push(root);

    // Process the tree in postorder
    while (!stack1.empty()) {
        struct Node* current = stack1.top();
        stack1.pop();
        stack2.push(current);

        if (current->left != NULL) {
            stack1.push(current->left);
        }
        if (current->right != NULL) {
            stack1.push(current->right);
        }
    }

    // Print the nodes in postorder
    while (!stack2.empty()) {
        struct Node* current = stack2.top();
        stack2.pop();
        printf("%d ", current->key);
    }
}

// Function to count the number of nodes in the binary tree
int countNodes(struct Node* root) {
    if (root == NULL) return 0;

    std::stack<struct Node*> stack;
    stack.push(root);
    int nodeCount = 0;

    while (!stack.empty()) {
        struct Node* current = stack.top();
        stack.pop();
        nodeCount++;

        if (current->right != NULL) {
            stack.push(current->right);
        }
        if (current->left != NULL) {
            stack.push(current->left);
        }
    }

    return nodeCount;
}

// Function to display the leaf nodes in the binary tree
void displayLeafNodes(struct Node* root) {
    if (root == NULL) return;

    std::stack<struct Node*> stack;
    stack.push(root);

    while (!stack.empty()) {
        struct Node* current = stack.top();
        stack.pop();

        // If it's a leaf node, print it
        if (current->left == NULL && current->right == NULL) {
            printf("%d ", current->key);
        }

        if (current->right != NULL) {
            stack.push(current->right);
        }
        if (current->left != NULL) {
            stack.push(current->left);
        }
    }
}

26)Write a Program to create a Binary Search Tree and perform deletion of a node from it. Also display the tree in nonrecursive postorder way
#include <stdio.h>
#include <stdlib.h>
#include <stack>

// Define the structure for the binary tree node
struct Node {
    int key;
    struct Node *left, *right;
};

// Function prototypes
struct Node* createNode(int key);
struct Node* insert(struct Node* root, int key);
struct Node* deleteNode(struct Node* root, int key);
struct Node* minValueNode(struct Node* node);
void postorderNonRecursive(struct Node* root);
void inorder(struct Node* root);  // To display the tree (inorder traversal)

// Main function
int main() {
    struct Node* root = NULL;

    // Insert nodes into the tree
    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);

    // Display the tree (In-order)
    printf("In-order Traversal of the Binary Search Tree:\n");
    inorder(root);
    printf("\n");

    // Delete node with value 50
    printf("Deleting node 50...\n");
    root = deleteNode(root, 50);

    // Display the tree after deletion (In-order)
    printf("In-order Traversal after Deletion:\n");
    inorder(root);
    printf("\n");

    // Post-order traversal (non-recursive)
    printf("Post-order Traversal (Non-recursive):\n");
    postorderNonRecursive(root);
    printf("\n");

    return 0;
}

// Function to create a new node
struct Node* createNode(int key) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node into the binary search tree
struct Node* insert(struct Node* root, int key) {
    if (root == NULL) {
        return createNode(key);
    }
    if (key < root->key) {
        root->left = insert(root->left, key);
    } else if (key > root->key) {
        root->right = insert(root->right, key);
    }
    return root;
}

// Function to find the minimum value node in a given tree
struct Node* minValueNode(struct Node* node) {
    struct Node* current = node;
    while (current && current->left != NULL) {
        current = current->left;
    }
    return current;
}

// Function to delete a node from the binary search tree
struct Node* deleteNode(struct Node* root, int key) {
    if (root == NULL) return root;

    // Find the node to be deleted
    if (key < root->key) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->key) {
        root->right = deleteNode(root->right, key);
    } else {
        // Node with only one child or no child
        if (root->left == NULL) {
            struct Node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct Node* temp = root->left;
            free(root);
            return temp;
        }

        // Node with two children: Get the inorder successor (smallest in the right subtree)
        struct Node* temp = minValueNode(root->right);

        // Copy the inorder successor's content to this node
        root->key = temp->key;

        // Delete the inorder successor
        root->right = deleteNode(root->right, temp->key);
    }
    return root;
}

// Function for non-recursive post-order traversal (left-right-root)
void postorderNonRecursive(struct Node* root) {
    if (root == NULL) return;

    std::stack<struct Node*> stack1, stack2;
    stack1.push(root);

    while (!stack1.empty()) {
        struct Node* current = stack1.top();
        stack1.pop();
        stack2.push(current);

        if (current->left != NULL) {
            stack1.push(current->left);
        }
        if (current->right != NULL) {
            stack1.push(current->right);
        }
    }

    // Print nodes in post-order
    while (!stack2.empty()) {
        struct Node* current = stack2.top();
        stack2.pop();
        printf("%d ", current->key);
    }
}

// Function for inorder traversal (for display purposes)
void inorder(struct Node* root) {
    if (root == NULL) return;

    std::stack<struct Node*> stack;
    struct Node* current = root;

    while (current != NULL || !stack.empty()) {
        while (current != NULL) {
            stack.push(current);
            current = current->left;
        }

        current = stack.top();
        stack.pop();
        printf("%d ", current->key);

        current = current->right;
    }
}

27)Write a Program to create a Binary Search Tree and display it levelwise. Also perform deletion of a node from it.
#include <stdio.h>
#include <stdlib.h>
#include <queue>

// Define the structure for the binary tree node
struct Node {
    int key;
    struct Node* left;
    struct Node* right;
};

// Function prototypes
struct Node* createNode(int key);
struct Node* insert(struct Node* root, int key);
struct Node* deleteNode(struct Node* root, int key);
struct Node* minValueNode(struct Node* node);
void levelOrderTraversal(struct Node* root);
void inorder(struct Node* root);  // To display the tree (inorder traversal)

// Main function
int main() {
    struct Node* root = NULL;

    // Insert nodes into the tree
    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);

    // Display the tree (Level-order)
    printf("Level-order Traversal of the Binary Search Tree:\n");
    levelOrderTraversal(root);
    printf("\n");

    // Delete node with value 50
    printf("Deleting node 50...\n");
    root = deleteNode(root, 50);

    // Display the tree after deletion (Level-order)
    printf("Level-order Traversal after Deletion:\n");
    levelOrderTraversal(root);
    printf("\n");

    return 0;
}

// Function to create a new node
struct Node* createNode(int key) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node into the binary search tree
struct Node* insert(struct Node* root, int key) {
    if (root == NULL) {
        return createNode(key);
    }
    if (key < root->key) {
        root->left = insert(root->left, key);
    } else if (key > root->key) {
        root->right = insert(root->right, key);
    }
    return root;
}

// Function to find the minimum value node in a given tree
struct Node* minValueNode(struct Node* node) {
    struct Node* current = node;
    while (current && current->left != NULL) {
        current = current->left;
    }
    return current;
}

// Function to delete a node from the binary search tree
struct Node* deleteNode(struct Node* root, int key) {
    if (root == NULL) return root;

    // Find the node to be deleted
    if (key < root->key) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->key) {
        root->right = deleteNode(root->right, key);
    } else {
        // Node to be deleted found
        if (root->left == NULL) {
            struct Node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct Node* temp = root->left;
            free(root);
            return temp;
        }

        // Node with two children: Get the inorder successor (smallest in the right subtree)
        struct Node* temp = minValueNode(root->right);

        // Copy the inorder successor's content to this node
        root->key = temp->key;

        // Delete the inorder successor
        root->right = deleteNode(root->right, temp->key);
    }
    return root;
}

// Function for level-order traversal (breadth-first traversal)
void levelOrderTraversal(struct Node* root) {
    if (root == NULL) return;

    struct Node* temp;
    std::queue<struct Node*> q;
    q.push(root);

    while (!q.empty()) {
        temp = q.front();
        q.pop();
        printf("%d ", temp->key);

        if (temp->left != NULL) {
            q.push(temp->left);
        }
        if (temp->right != NULL) {
            q.push(temp->right);
        }
    }
}

// Function for inorder traversal (for display purposes)
void inorder(struct Node* root) {
    if (root == NULL) return;

    inorder(root->left);
    printf("%d ", root->key);
    inorder(root->right);
}

28)Write a Program to create a Binary Search Tree and display its mirror image with and without disturbing the original tree. Also display height of a tree using nonrecursion. 
#include <stdio.h>
#include <stdlib.h>
#include <stack>

// Define the structure for the binary tree node
struct Node {
    int key;
    struct Node* left;
    struct Node* right;
};

// Function prototypes
struct Node* createNode(int key);
struct Node* insert(struct Node* root, int key);
void inorder(struct Node* root);  // To display the tree (inorder traversal)
void mirrorImage(struct Node* root);
void mirrorImageCopy(struct Node* root);
int heightNonRecursive(struct Node* root);
void levelOrderTraversal(struct Node* root);

// Main function
int main() {
    struct Node* root = NULL;

    // Insert nodes into the tree
    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);

    // Display the original tree (In-order)
    printf("In-order Traversal of the Original Binary Search Tree:\n");
    inorder(root);
    printf("\n");

    // Display the mirror image without disturbing the original tree
    printf("Mirror Image of the Binary Search Tree (Without Disturbing Original):\n");
    mirrorImageCopy(root);
    printf("\n");

    // Display the mirror image by disturbing the original tree
    printf("Mirror Image of the Binary Search Tree (Disturbing Original):\n");
    mirrorImage(root);
    printf("\n");

    // Display the height of the tree (Non-recursive)
    printf("Height of the Binary Search Tree (Non-recursive): %d\n", heightNonRecursive(root));

    // Display the tree level-wise
    printf("Level-order Traversal of the Tree:\n");
    levelOrderTraversal(root);
    printf("\n");

    return 0;
}

// Function to create a new node
struct Node* createNode(int key) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node into the binary search tree
struct Node* insert(struct Node* root, int key) {
    if (root == NULL) {
        return createNode(key);
    }
    if (key < root->key) {
        root->left = insert(root->left, key);
    } else if (key > root->key) {
        root->right = insert(root->right, key);
    }
    return root;
}

// Inorder traversal (For displaying the tree)
void inorder(struct Node* root) {
    if (root == NULL) return;
    inorder(root->left);
    printf("%d ", root->key);
    inorder(root->right);
}

// Function to create and display the mirror image without disturbing the original tree
void mirrorImageCopy(struct Node* root) {
    if (root == NULL) return;

    // Create a new mirrored tree using stack
    struct Node* mirroredRoot = NULL;
    std::stack<struct Node*> stack;
    stack.push(root);

    while (!stack.empty()) {
        struct Node* node = stack.top();
        stack.pop();

        if (node == NULL) continue;

        // Create a mirror node (swap left and right)
        struct Node* mirroredNode = createNode(node->key);
        mirroredNode->left = node->right;
        mirroredNode->right = node->left;

        // Push the left and right children of the original node into the stack
        stack.push(node->left);
        stack.push(node->right);

        // Print the mirrored node's key (For visualization)
        printf("%d ", mirroredNode->key);
    }
}

// Function to create and display the mirror image by disturbing the original tree
void mirrorImage(struct Node* root) {
    if (root == NULL) return;

    // Swap the left and right children of the current node
    struct Node* temp = root->left;
    root->left = root->right;
    root->right = temp;

    // Recur for the left and right subtrees
    mirrorImage(root->left);
    mirrorImage(root->right);
}

// Non-recursive function to calculate the height of the tree
int heightNonRecursive(struct Node* root) {
    if (root == NULL) return 0;

    std::stack<std::pair<struct Node*, int>> stack;
    stack.push(std::make_pair(root, 1));  // Push the root node with height 1
    int maxHeight = 0;

    while (!stack.empty()) {
        struct Node* node = stack.top().first;
        int height = stack.top().second;
        stack.pop();

        if (node == NULL) continue;

        maxHeight = (height > maxHeight) ? height : maxHeight;

        // Push the right and left child nodes with their respective height
        stack.push(std::make_pair(node->right, height + 1));
        stack.push(std::make_pair(node->left, height + 1));
    }

    return maxHeight;
}

// Function for level-order traversal (breadth-first traversal)
void levelOrderTraversal(struct Node* root) {
    if (root == NULL) return;

    struct Node* temp;
    std::queue<struct Node*> q;
    q.push(root);

    while (!q.empty()) {
        temp = q.front();
        q.pop();
        printf("%d ", temp->key);

        if (temp->left != NULL) {
            q.push(temp->left);
        }
        if (temp->right != NULL) {
            q.push(temp->right);
        }
    }
}

29)Write a program, using trees, to assign the roll nos. to the students of your class as per their previous years result. i.e topper will be roll no. 1. 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the structure for a student node
struct StudentNode {
    int marks;
    char name[50];
    int rollNo;
    struct StudentNode* left;
    struct StudentNode* right;
};

// Function prototypes
struct StudentNode* createNode(int marks, char* name);
struct StudentNode* insert(struct StudentNode* root, int marks, char* name);
void inorderAssignRollNo(struct StudentNode* root, int* rollNo);
void inorder(struct StudentNode* root);

// Main function
int main() {
    struct StudentNode* root = NULL;
    int rollNo = 1;

    // Insert students into the tree
    root = insert(root, 85, "Alice");
    root = insert(root, 90, "Bob");
    root = insert(root, 75, "Charlie");
    root = insert(root, 95, "David");
    root = insert(root, 80, "Eve");

    // In-order traversal to assign roll numbers
    inorderAssignRollNo(root, &rollNo);

    // Display students with their assigned roll numbers
    printf("\nStudents with Assigned Roll Numbers:\n");
    inorder(root);

    return 0;
}

// Function to create a new student node
struct StudentNode* createNode(int marks, char* name) {
    struct StudentNode* newNode = (struct StudentNode*)malloc(sizeof(struct StudentNode));
    newNode->marks = marks;
    strcpy(newNode->name, name);
    newNode->rollNo = 0;  // Roll number will be assigned later
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a new student node in the BST
struct StudentNode* insert(struct StudentNode* root, int marks, char* name) {
    if (root == NULL) {
        return createNode(marks, name);
    }

    if (marks < root->marks) {
        root->left = insert(root->left, marks, name);
    } else if (marks > root->marks) {
        root->right = insert(root->right, marks, name);
    }

    return root;
}

// In-order traversal to assign roll numbers starting from 1
void inorderAssignRollNo(struct StudentNode* root, int* rollNo) {
    if (root == NULL) return;

    inorderAssignRollNo(root->left, rollNo); // Left subtree

    // Assign the roll number based on the in-order traversal
    root->rollNo = (*rollNo);
    (*rollNo)++;

    inorderAssignRollNo(root->right, rollNo); // Right subtree
}

// In-order traversal to display the students with their roll numbers
void inorder(struct StudentNode* root) {
    if (root == NULL) return;

    inorder(root->left); // Left subtree

    // Print the student's name, marks, and assigned roll number
    printf("Name: %s, Marks: %d, Roll No: %d\n", root->name, root->marks, root->rollNo);

    inorder(root->right); // Right subtree
}

30)Write a program to efficiently search a perticular employee record by using Tree data structure. Also sort the data on emp-id in ascending order. 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the structure for an employee node
struct Employee {
    int emp_id;
    char name[50];
    int age;
    float salary;
    struct Employee* left;
    struct Employee* right;
};

// Function prototypes
struct Employee* createNode(int emp_id, char* name, int age, float salary);
struct Employee* insert(struct Employee* root, int emp_id, char* name, int age, float salary);
struct Employee* search(struct Employee* root, int emp_id);
void inorder(struct Employee* root);

int main() {
    struct Employee* root = NULL;
    struct Employee* foundEmployee;
    
    // Insert employee records into the BST
    root = insert(root, 101, "Alice", 30, 50000);
    root = insert(root, 102, "Bob", 28, 55000);
    root = insert(root, 105, "Charlie", 35, 60000);
    root = insert(root, 104, "David", 32, 70000);
    root = insert(root, 103, "Eve", 29, 45000);
    
    // Display employees in ascending order of emp-id
    printf("Employee records sorted by emp-id:\n");
    inorder(root);
    
    // Search for an employee by emp_id
    printf("\nEnter emp_id to search: ");
    int search_id;
    scanf("%d", &search_id);
    foundEmployee = search(root, search_id);
    if (foundEmployee != NULL) {
        printf("\nEmployee found: %s, Age: %d, Salary: %.2f\n", foundEmployee->name, foundEmployee->age, foundEmployee->salary);
    } else {
        printf("\nEmployee with emp_id %d not found.\n", search_id);
    }

    return 0;
}

// Function to create a new employee node
struct Employee* createNode(int emp_id, char* name, int age, float salary) {
    struct Employee* newNode = (struct Employee*)malloc(sizeof(struct Employee));
    newNode->emp_id = emp_id;
    strcpy(newNode->name, name);
    newNode->age = age;
    newNode->salary = salary;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a new employee node into the BST
struct Employee* insert(struct Employee* root, int emp_id, char* name, int age, float salary) {
    if (root == NULL) {
        return createNode(emp_id, name, age, salary);
    }
    
    if (emp_id < root->emp_id) {
        root->left = insert(root->left, emp_id, name, age, salary);
    } else if (emp_id > root->emp_id) {
        root->right = insert(root->right, emp_id, name, age, salary);
    }
    
    return root;
}

// Function to search for an employee by emp_id
struct Employee* search(struct Employee* root, int emp_id) {
    if (root == NULL || root->emp_id == emp_id) {
        return root;
    }
    
    if (emp_id < root->emp_id) {
        return search(root->left, emp_id);
    } else {
        return search(root->right, emp_id);
    }
}

// In-order traversal to display employees sorted by emp_id
void inorder(struct Employee* root) {
    if (root != NULL) {
        inorder(root->left); // Traverse the left subtree
        printf("Emp ID: %d, Name: %s, Age: %d, Salary: %.2f\n", root->emp_id, root->name, root->age, root->salary);
        inorder(root->right); // Traverse the right subtree
    }
}

Q31 Write a Program to accept a graph from a user and represent it with Adjacency Matrix and perform BFS and DFS traversals on it.
#include <s
tdio.h>
#include <stdlib.h>

#define MAX 10  // Maximum number of vertices

int adjMatrix[MAX][MAX];
int visited[MAX];

// Function to initialize the adjacency matrix
void initializeMatrix(int vertices) {
    for (int i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            adjMatrix[i][j] = 0;
        }
    }
}

// Function to create the adjacency matrix
void createGraph(int vertices) {
    int u, v, edges;
    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    for (int i = 0; i < edges; i++) {
        printf("Enter edge (u v): ");
        scanf("%d %d", &u, &v);
        adjMatrix[u][v] = 1;
        adjMatrix[v][u] = 1;  // For undirected graph
    }
}

// Function for DFS traversal
void DFS(int vertex, int vertices) {
    printf("%d ", vertex);
    visited[vertex] = 1;

    for (int i = 0; i < vertices; i++) {
        if (adjMatrix[vertex][i] == 1 && !visited[i]) {
            DFS(i, vertices);
        }
    }
}

// Function for BFS traversal
void BFS(int start, int vertices) {
    int queue[MAX], front = 0, rear = -1;
    int current;
    for (int i = 0; i < vertices; i++) visited[i] = 0;

    queue[++rear] = start;
    visited[start] = 1;

    while (front <= rear) {
        current = queue[front++];
        printf("%d ", current);

        for (int i = 0; i < vertices; i++) {
            if (adjMatrix[current][i] == 1 && !visited[i]) {
                queue[++rear] = i;
                visited[i] = 1;
            }
        }
    }
}

int main() {
    int vertices, start;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    initializeMatrix(vertices);
    createGraph(vertices);

    printf("\nAdjacency Matrix:\n");
    for (int i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            printf("%d ", adjMatrix[i][j]);
        }
        printf("\n");
    }

    printf("\nEnter the starting vertex for DFS: ");
    scanf("%d", &start);
    for (int i = 0; i < vertices; i++) visited[i] = 0;  // Reset visited array
    printf("DFS Traversal: ");
    DFS(start, vertices);
    printf("\n");

    printf("\nEnter the starting vertex for BFS: ");
    scanf("%d", &start);
    printf("BFS Traversal: ");
    BFS(start, vertices);
    printf("\n");

    return 0;
}

Q32 Write a Program to implement Primâ€™s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency List to represent a graph.
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define MAX 10  // Maximum number of vertices

// Structure to represent a node in the adjacency list
typedef struct Node {
    int vertex, weight;
    struct Node* next;
} Node;

// Structure to represent a graph
typedef struct Graph {
    Node* adjList[MAX];
    int vertices;
} Graph;

// Structure to represent a min-priority queue node
typedef struct MinHeapNode {
    int vertex, key;
} MinHeapNode;

// Utility functions
Node* createNode(int vertex, int weight) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = vertex;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

// Initialize graph
void initializeGraph(Graph* graph, int vertices) {
    graph->vertices = vertices;
    for (int i = 0; i < vertices; i++) {
        graph->adjList[i] = NULL;
    }
}

// Add an edge to the graph
void addEdge(Graph* graph, int src, int dest, int weight) {
    Node* newNode = createNode(dest, weight);
    newNode->next = graph->adjList[src];
    graph->adjList[src] = newNode;

    // For undirected graph
    newNode = createNode(src, weight);
    newNode->next = graph->adjList[dest];
    graph->adjList[dest] = newNode;
}

// Find the vertex with minimum key value not yet included in MST
int minKey(int key[], int inMST[], int vertices) {
    int min = INT_MAX, minIndex = -1;

    for (int v = 0; v < vertices; v++) {
        if (!inMST[v] && key[v] < min) {
            min = key[v];
            minIndex = v;
        }
    }
    return minIndex;
}

// Prim's Algorithm
void primMST(Graph* graph) {
    int parent[MAX], key[MAX], inMST[MAX];
    int vertices = graph->vertices;

    for (int i = 0; i < vertices; i++) {
        key[i] = INT_MAX;
        inMST[i] = 0;
    }

    key[0] = 0;  // Start from the first vertex
    parent[0] = -1;

    for (int count = 0; count < vertices - 1; count++) {
        int u = minKey(key, inMST, vertices);
        inMST[u] = 1;

        Node* temp = graph->adjList[u];
        while (temp) {
            int v = temp->vertex;
            if (!inMST[v] && temp->weight < key[v]) {
                key[v] = temp->weight;
                parent[v] = u;
            }
            temp = temp->next;
        }
    }

    // Print the MST
    printf("Edge\tWeight\n");
    for (int i = 1; i < vertices; i++) {
        printf("%d - %d\t%d\n", parent[i], i, key[i]);
    }
}

int main() {
    Graph graph;
    int vertices, edges, src, dest, weight;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    initializeGraph(&graph, vertices);

    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    for (int i = 0; i < edges; i++) {
        printf("Enter edge (src dest weight): ");
        scanf("%d %d %d", &src, &dest, &weight);
        addEdge(&graph, src, dest, weight);
    }

    printf("\nMinimum Spanning Tree using Prim's Algorithm:\n");
    primMST(&graph);

    return 0;
}
Q33 Write a Program to implement Kruskalâ€™s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency List to represent a graph.
#include <stdio.h>
#include <stdlib.h>

#define MAX 10  // Maximum number of vertices

// Structure to represent an edge
typedef struct Edge {
    int src, dest, weight;
} Edge;

// Structure to represent a graph
typedef struct Graph {
    int vertices, edges;
    Edge edgeList[MAX];
} Graph;

// Structure to represent a subset for union-find
typedef struct Subset {
    int parent, rank;
} Subset;

// Utility functions for union-find
int find(Subset subsets[], int i) {
    if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent); // Path compression
    return subsets[i].parent;
}

void unionSets(Subset subsets[], int x, int y) {
    int rootX = find(subsets, x);
    int rootY = find(subsets, y);

    if (subsets[rootX].rank < subsets[rootY].rank) {
        subsets[rootX].parent = rootY;
    } else if (subsets[rootX].rank > subsets[rootY].rank) {
        subsets[rootY].parent = rootX;
    } else {
        subsets[rootY].parent = rootX;
        subsets[rootX].rank++;
    }
}

// Function to compare edges based on their weight
int compareEdges(const void* a, const void* b) {
    Edge* edgeA = (Edge*)a;
    Edge* edgeB = (Edge*)b;
    return edgeA->weight - edgeB->weight;
}

// Kruskal's Algorithm
void kruskalMST(Graph* graph) {
    int vertices = graph->vertices;
    Edge result[MAX];  // Array to store the MST
    int e = 0;  // Index for result[]
    int i = 0;  // Index for sorted edges

    // Step 1: Sort edges in non-decreasing order of weight
    qsort(graph->edgeList, graph->edges, sizeof(Edge), compareEdges);

    // Step 2: Initialize subsets for union-find
    Subset* subsets = (Subset*)malloc(vertices * sizeof(Subset));
    for (int v = 0; v < vertices; v++) {
        subsets[v].parent = v;
        subsets[v].rank = 0;
    }

    // Step 3: Pick the smallest edge and check for cycles
    while (e < vertices - 1 && i < graph->edges) {
        Edge nextEdge = graph->edgeList[i++];

        int x = find(subsets, nextEdge.src);
        int y = find(subsets, nextEdge.dest);

        if (x != y) {  // If including this edge doesn't form a cycle
            result[e++] = nextEdge;
            unionSets(subsets, x, y);
        }
    }

    // Print the MST
    printf("Edge\tWeight\n");
    for (i = 0; i < e; i++) {
        printf("%d - %d\t%d\n", result[i].src, result[i].dest, result[i].weight);
    }

    free(subsets);
}

// Function to create a graph
void createGraph(Graph* graph) {
    printf("Enter the number of vertices: ");
    scanf("%d", &graph->vertices);

    printf("Enter the number of edges: ");
    scanf("%d", &graph->edges);

    for (int i = 0; i < graph->edges; i++) {
        printf("Enter edge (src dest weight): ");
        scanf("%d %d %d", &graph->edgeList[i].src, &graph->edgeList[i].dest, &graph->edgeList[i].weight);
    }
}

int main() {
    Graph graph;
    createGraph(&graph);

    printf("\nMinimum Spanning Tree using Kruskal's Algorithm:\n");
    kruskalMST(&graph);

    return 0;
}
Q34 Write a Program to implement Kruskalâ€™s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency List to represent a graph.
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define MAX 10  // Maximum number of vertices

// Structure to represent an edge
typedef struct Edge {
    int src, dest, weight;
} Edge;

// Structure to represent a graph
typedef struct Graph {
    int vertices, edges;
    struct Node* adjList[MAX];
    Edge edgeList[MAX];
} Graph;

// Structure to represent a node in adjacency list
typedef struct Node {
    int vertex, weight;
    struct Node* next;
} Node;

// Structure to represent a subset for union-find
typedef struct Subset {
    int parent, rank;
} Subset;

// Function to create a new adjacency list node
Node* createNode(int vertex, int weight) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = vertex;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

// Function to add an edge to the adjacency list and edge list
void addEdge(Graph* graph, int src, int dest, int weight, int index) {
    Node* newNode = createNode(dest, weight);
    newNode->next = graph->adjList[src];
    graph->adjList[src] = newNode;

    Node* newNodeReverse = createNode(src, weight);
    newNodeReverse->next = graph->adjList[dest];
    graph->adjList[dest] = newNodeReverse;

    // Add to edge list
    graph->edgeList[index].src = src;
    graph->edgeList[index].dest = dest;
    graph->edgeList[index].weight = weight;
}

// Find operation for union-find
int find(Subset subsets[], int i) {
    if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent);
    return subsets[i].parent;
}

// Union operation for union-find
void unionSets(Subset subsets[], int x, int y) {
    int rootX = find(subsets, x);
    int rootY = find(subsets, y);

    if (subsets[rootX].rank < subsets[rootY].rank) {
        subsets[rootX].parent = rootY;
    } else if (subsets[rootX].rank > subsets[rootY].rank) {
        subsets[rootY].parent = rootX;
    } else {
        subsets[rootY].parent = rootX;
        subsets[rootX].rank++;
    }
}

// Comparison function for sorting edges by weight
int compareEdges(const void* a, const void* b) {
    Edge* edgeA = (Edge*)a;
    Edge* edgeB = (Edge*)b;
    return edgeA->weight - edgeB->weight;
}

// Function to print adjacency list
void printAdjList(Graph* graph) {
    printf("\nAdjacency List:\n");
    for (int i = 0; i < graph->vertices; i++) {
        printf("Vertex %d: ", i);
        Node* temp = graph->adjList[i];
        while (temp) {
            printf("-> (%d, %d) ", temp->vertex, temp->weight);
            temp = temp->next;
        }
        printf("\n");
    }
}

// Kruskal's Algorithm
void kruskalMST(Graph* graph) {
    int vertices = graph->vertices;
    Edge result[MAX];  // Array to store MST
    int e = 0;         // Index for result[]
    int i = 0;         // Index for sorted edges

    // Step 1: Sort edges by weight
    qsort(graph->edgeList, graph->edges, sizeof(Edge), compareEdges);

    // Step 2: Create subsets for union-find
    Subset* subsets = (Subset*)malloc(vertices * sizeof(Subset));
    for (int v = 0; v < vertices; v++) {
        subsets[v].parent = v;
        subsets[v].rank = 0;
    }

    // Step 3: Process edges
    while (e < vertices - 1 && i < graph->edges) {
        Edge nextEdge = graph->edgeList[i++];
        int x = find(subsets, nextEdge.src);
        int y = find(subsets, nextEdge.dest);

        if (x != y) {
            result[e++] = nextEdge;
            unionSets(subsets, x, y);
        }
    }

    // Print the MST
    printf("\nMinimum Spanning Tree:\n");
    printf("Edge\tWeight\n");
    for (i = 0; i < e; i++) {
        printf("%d - %d\t%d\n", result[i].src, result[i].dest, result[i].weight);
    }

    free(subsets);
}

int main() {
    Graph graph;
    int vertices, edges;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);
    graph.vertices = vertices;

    printf("Enter the number of edges: ");
    scanf("%d", &edges);
    graph.edges = edges;

    for (int i = 0; i < vertices; i++) {
        graph.adjList[i] = NULL;
    }

    for (int i = 0; i < edges; i++) {
        int src, dest, weight;
        printf("Enter edge (src dest weight): ");
        scanf("%d %d %d", &src, &dest, &weight);
        addEdge(&graph, src, dest, weight, i);
    }

    printAdjList(&graph);
    kruskalMST(&graph);

    return 0;
}

Q35 Write a Program to implement Dijkstraâ€™s algorithm to find shortest distance between two nodes of a user defined graph. Use Adjacency List to represent a graph.
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define MAX 10  // Maximum number of vertices

// Structure to represent a node in adjacency list
typedef struct Node {
    int vertex, weight;
    struct Node* next;
} Node;

// Structure to represent a graph
typedef struct Graph {
    Node* adjList[MAX];
    int vertices;
} Graph;

// Min Heap Node for priority queue
typedef struct MinHeapNode {
    int vertex, dist;
} MinHeapNode;

// Create a new adjacency list node
Node* createNode(int vertex, int weight) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = vertex;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

// Initialize graph
void initializeGraph(Graph* graph, int vertices) {
    graph->vertices = vertices;
    for (int i = 0; i < vertices; i++) {
        graph->adjList[i] = NULL;
    }
}

// Add an edge to the adjacency list
void addEdge(Graph* graph, int src, int dest, int weight) {
    Node* newNode = createNode(dest, weight);
    newNode->next = graph->adjList[src];
    graph->adjList[src] = newNode;

    // Since it's an undirected graph, add the reverse edge
    newNode = createNode(src, weight);
    newNode->next = graph->adjList[dest];
    graph->adjList[dest] = newNode;
}

// Function to find the vertex with minimum distance
int findMinDistance(int dist[], int visited[], int vertices) {
    int min = INT_MAX, minIndex = -1;
    for (int v = 0; v < vertices; v++) {
        if (!visited[v] && dist[v] < min) {
            min = dist[v];
            minIndex = v;
        }
    }
    return minIndex;
}

// Dijkstra's Algorithm
void dijkstra(Graph* graph, int start, int target) {
    int dist[MAX], visited[MAX];
    int parent[MAX];
    int vertices = graph->vertices;

    // Initialize distances and visited array
    for (int i = 0; i < vertices; i++) {
        dist[i] = INT_MAX;
        visited[i] = 0;
        parent[i] = -1;
    }
    dist[start] = 0;

    for (int count = 0; count < vertices - 1; count++) {
        int u = findMinDistance(dist, visited, vertices);
        visited[u] = 1;

        Node* temp = graph->adjList[u];
        while (temp) {
            int v = temp->vertex;
            int weight = temp->weight;

            if (!visited[v] && dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                parent[v] = u;
            }
            temp = temp->next;
        }
    }

    // Print shortest path distance
    printf("\nShortest distance from %d to %d is: %d\n", start, target, dist[target]);

    // Trace and print the path
    printf("Path: ");
    int path[MAX];
    int count = 0, current = target;
    while (current != -1) {
        path[count++] = current;
        current = parent[current];
    }
    for (int i = count - 1; i >= 0; i--) {
        printf("%d ", path[i]);
        if (i != 0) printf("-> ");
    }
    printf("\n");
}

int main() {
    Graph graph;
    int vertices, edges;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);
    initializeGraph(&graph, vertices);

    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    for (int i = 0; i < edges; i++) {
        int src, dest, weight;
        printf("Enter edge (src dest weight): ");
        scanf("%d %d %d", &src, &dest, &weight);
        addEdge(&graph, src, dest, weight);
    }

    int start, target;
    printf("Enter the starting vertex: ");
    scanf("%d", &start);
    printf("Enter the target vertex: ");
    scanf("%d", &target);

    dijkstra(&graph, start, target);

    return 0;
}

Q36 Write a Program to accept a graph from user and represent it with Adjacency List and perform BFS and DFS traversals on it.
#include <stdio.h>
#include <stdlib.h>

#define MAX 10  // Maximum number of vertices

// Structure to represent a node in the adjacency list
typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

// Structure to represent a graph
typedef struct Graph {
    Node* adjList[MAX];
    int vertices;
} Graph;

// Create a new adjacency list node
Node* createNode(int vertex) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = vertex;
    newNode->next = NULL;
    return newNode;
}

// Initialize graph
void initializeGraph(Graph* graph, int vertices) {
    graph->vertices = vertices;
    for (int i = 0; i < vertices; i++) {
        graph->adjList[i] = NULL;
    }
}

// Add an edge to the adjacency list
void addEdge(Graph* graph, int src, int dest) {
    Node* newNode = createNode(dest);
    newNode->next = graph->adjList[src];
    graph->adjList[src] = newNode;

    // Since the graph is undirected, add the reverse edge
    newNode = createNode(src);
    newNode->next = graph->adjList[dest];
    graph->adjList[dest] = newNode;
}

// BFS Traversal
void bfs(Graph* graph, int startVertex) {
    int visited[MAX] = {0};
    int queue[MAX], front = 0, rear = 0;

    printf("BFS Traversal: ");
    visited[startVertex] = 1;
    queue[rear++] = startVertex;

    while (front != rear) {
        int currentVertex = queue[front++];
        printf("%d ", currentVertex);

        Node* temp = graph->adjList[currentVertex];
        while (temp) {
            int adjVertex = temp->vertex;
            if (!visited[adjVertex]) {
                visited[adjVertex] = 1;
                queue[rear++] = adjVertex;
            }
            temp = temp->next;
        }
    }
    printf("\n");
}

// DFS Traversal (Recursive)
void dfsUtil(Graph* graph, int vertex, int visited[]) {
    visited[vertex] = 1;
    printf("%d ", vertex);

    Node* temp = graph->adjList[vertex];
    while (temp) {
        int adjVertex = temp->vertex;
        if (!visited[adjVertex]) {
            dfsUtil(graph, adjVertex, visited);
        }
        temp = temp->next;
    }
}

void dfs(Graph* graph, int startVertex) {
    int visited[MAX] = {0};
    printf("DFS Traversal: ");
    dfsUtil(graph, startVertex, visited);
    printf("\n");
}

// Function to print the adjacency list
void printAdjList(Graph* graph) {
    printf("\nAdjacency List:\n");
    for (int i = 0; i < graph->vertices; i++) {
        printf("Vertex %d: ", i);
        Node* temp = graph->adjList[i];
        while (temp) {
            printf("-> %d ", temp->vertex);
            temp = temp->next;
        }
        printf("\n");
    }
}

int main() {
    Graph graph;
    int vertices, edges;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);
    initializeGraph(&graph, vertices);

    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    for (int i = 0; i < edges; i++) {
        int src, dest;
        printf("Enter edge (src dest): ");
        scanf("%d %d", &src, &dest);
        addEdge(&graph, src, dest);
    }

    printAdjList(&graph);

    int startVertex;
    printf("\nEnter the starting vertex for BFS and DFS: ");
    scanf("%d", &startVertex);

    bfs(&graph, startVertex);
    dfs(&graph, startVertex);

    return 0;
}

Q37 Write a Program to implement Kruskalâ€™s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency Matrix to represent a graph.
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define MAX 10  // Maximum number of vertices

// Structure to represent an edge
typedef struct Edge {
    int src, dest, weight;
} Edge;

// Structure to represent a subset for union-find
typedef struct Subset {
    int parent, rank;
} Subset;

// Find operation for union-find
int find(Subset subsets[], int i) {
    if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent);
    return subsets[i].parent;
}

// Union operation for union-find
void unionSets(Subset subsets[], int x, int y) {
    int rootX = find(subsets, x);
    int rootY = find(subsets, y);

    if (subsets[rootX].rank < subsets[rootY].rank) {
        subsets[rootX].parent = rootY;
    } else if (subsets[rootX].rank > subsets[rootY].rank) {
        subsets[rootY].parent = rootX;
    } else {
        subsets[rootY].parent = rootX;
        subsets[rootX].rank++;
    }
}

// Comparison function for sorting edges by weight
int compareEdges(const void* a, const void* b) {
    Edge* edgeA = (Edge*)a;
    Edge* edgeB = (Edge*)b;
    return edgeA->weight - edgeB->weight;
}

// Function to print the adjacency matrix
void printAdjMatrix(int graph[MAX][MAX], int vertices) {
    printf("\nAdjacency Matrix:\n");
    for (int i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            printf("%d ", graph[i][j]);
        }
        printf("\n");
    }
}

// Kruskal's Algorithm
void kruskalMST(int graph[MAX][MAX], int vertices) {
    Edge edges[MAX * MAX];  // Array to store all edges
    int edgeCount = 0;

    // Convert adjacency matrix to edge list
    for (int i = 0; i < vertices; i++) {
        for (int j = i + 1; j < vertices; j++) {  // Avoid duplicate edges
            if (graph[i][j] != 0) {
                edges[edgeCount].src = i;
                edges[edgeCount].dest = j;
                edges[edgeCount].weight = graph[i][j];
                edgeCount++;
            }
        }
    }

    // Sort edges by weight
    qsort(edges, edgeCount, sizeof(Edge), compareEdges);

    // Create subsets for union-find
    Subset subsets[MAX];
    for (int i = 0; i < vertices; i++) {
        subsets[i].parent = i;
        subsets[i].rank = 0;
    }

    // Process edges
    Edge result[MAX];  // Store the MST edges
    int e = 0;         // Index for result[]
    for (int i = 0; i < edgeCount && e < vertices - 1; i++) {
        Edge nextEdge = edges[i];
        int x = find(subsets, nextEdge.src);
        int y = find(subsets, nextEdge.dest);

        if (x != y) {  // No cycle
            result[e++] = nextEdge;
            unionSets(subsets, x, y);
        }
    }

    // Print the MST
    printf("\nMinimum Spanning Tree:\n");
    printf("Edge\tWeight\n");
    for (int i = 0; i < e; i++) {
        printf("%d - %d\t%d\n", result[i].src, result[i].dest, result[i].weight);
    }
}

int main() {
    int graph[MAX][MAX], vertices;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    printf("Enter the adjacency matrix (enter 0 for no edge):\n");
    for (int i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            scanf("%d", &graph[i][j]);
        }
    }

    printAdjMatrix(graph, vertices);
    kruskalMST(graph, vertices);

    return 0;
}

Q38 Write a Program to implement Dijkstraâ€™s algorithm to find shortest distance between two nodes of a user defined graph. Use Adjacency Matrix to represent a graph.
#include <stdio.h>
#include <limits.h>

#define MAX 10  // Maximum number of vertices
#define INF INT_MAX  // Infinity for unreachable nodes

// Function to find the vertex with the minimum distance
int findMinDistance(int dist[], int visited[], int vertices) {
    int min = INF, minIndex = -1;
    for (int v = 0; v < vertices; v++) {
        if (!visited[v] && dist[v] < min) {
            min = dist[v];
            minIndex = v;
        }
    }
    return minIndex;
}

// Dijkstra's Algorithm
void dijkstra(int graph[MAX][MAX], int vertices, int start, int target) {
    int dist[MAX], visited[MAX], parent[MAX];

    // Initialize distances and visited array
    for (int i = 0; i < vertices; i++) {
        dist[i] = INF;
        visited[i] = 0;
        parent[i] = -1;
    }
    dist[start] = 0;

    for (int count = 0; count < vertices - 1; count++) {
        int u = findMinDistance(dist, visited, vertices);
        if (u == -1) break;  // All reachable nodes are processed
        visited[u] = 1;

        for (int v = 0; v < vertices; v++) {
            if (!visited[v] && graph[u][v] && dist[u] != INF && dist[u] + graph[u][v] < dist[v]) {
                dist[v] = dist[u] + graph[u][v];
                parent[v] = u;
            }
        }
    }

    // Print shortest distance and path
    if (dist[target] == INF) {
        printf("\nNo path exists between %d and %d.\n", start, target);
    } else {
        printf("\nShortest distance from %d to %d is: %d\n", start, target, dist[target]);
        printf("Path: ");
        int path[MAX], count = 0, current = target;
        while (current != -1) {
            path[count++] = current;
            current = parent[current];
        }
        for (int i = count - 1; i >= 0; i--) {
            printf("%d", path[i]);
            if (i != 0) printf(" -> ");
        }
        printf("\n");
    }
}

int main() {
    int graph[MAX][MAX], vertices;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    printf("Enter the adjacency matrix (enter 0 for no edge):\n");
    for (int i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            scanf("%d", &graph[i][j]);
        }
    }

    int start, target;
    printf("Enter the starting vertex: ");
    scanf("%d", &start);
    printf("Enter the target vertex: ");
    scanf("%d", &target);

    dijkstra(graph, vertices, start, target);

    return 0;
}

Q39 Write a Program to implement Primâ€™s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency List to represent a graph.
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define MAX 10  // Maximum number of vertices

// Structure to represent a node in the adjacency list
typedef struct Node {
    int vertex;
    int weight;
    struct Node* next;
} Node;

// Structure to represent an edge in the priority queue
typedef struct Edge {
    int src, dest, weight;
} Edge;

// Structure to represent a graph
typedef struct Graph {
    Node* adjList[MAX];
    int vertices;
} Graph;

// Create a new adjacency list node
Node* createNode(int vertex, int weight) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = vertex;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

// Initialize graph
void initializeGraph(Graph* graph, int vertices) {
    graph->vertices = vertices;
    for (int i = 0; i < vertices; i++) {
        graph->adjList[i] = NULL;
    }
}

// Add an edge to the adjacency list
void addEdge(Graph* graph, int src, int dest, int weight) {
    Node* newNode = createNode(dest, weight);
    newNode->next = graph->adjList[src];
    graph->adjList[src] = newNode;

    // For undirected graph, add reverse edge
    newNode = createNode(src, weight);
    newNode->next = graph->adjList[dest];
    graph->adjList[dest] = newNode;
}

// Function to print the adjacency list
void printAdjList(Graph* graph) {
    printf("\nAdjacency List:\n");
    for (int i = 0; i < graph->vertices; i++) {
        printf("Vertex %d: ", i);
        Node* temp = graph->adjList[i];
        while (temp) {
            printf("-> (%d, %d) ", temp->vertex, temp->weight);
            temp = temp->next;
        }
        printf("\n");
    }
}

// Function to find the vertex with the minimum key value
int findMinKey(int key[], int mstSet[], int vertices) {
    int min = INT_MAX, minIndex = -1;
    for (int v = 0; v < vertices; v++) {
        if (!mstSet[v] && key[v] < min) {
            min = key[v];
            minIndex = v;
        }
    }
    return minIndex;
}

// Prim's Algorithm
void primMST(Graph* graph) {
    int vertices = graph->vertices;
    int parent[MAX], key[MAX], mstSet[MAX];

    // Initialize arrays
    for (int i = 0; i < vertices; i++) {
        key[i] = INT_MAX;
        mstSet[i] = 0;
        parent[i] = -1;
    }

    // Start from vertex 0
    key[0] = 0;

    for (int count = 0; count < vertices - 1; count++) {
        int u = findMinKey(key, mstSet, vertices);
        mstSet[u] = 1;

        // Update key values of adjacent vertices
        Node* temp = graph->adjList[u];
        while (temp) {
            int v = temp->vertex;
            if (!mstSet[v] && temp->weight < key[v]) {
                key[v] = temp->weight;
                parent[v] = u;
            }
            temp = temp->next;
        }
    }

    // Print the MST
    printf("\nMinimum Spanning Tree:\n");
    printf("Edge\tWeight\n");
    for (int i = 1; i < vertices; i++) {
        printf("%d - %d\t%d\n", parent[i], i, key[i]);
    }
}

int main() {
    Graph graph;
    int vertices, edges;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);
    initializeGraph(&graph, vertices);

    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    printf("Enter the edges in the format (src dest weight):\n");
    for (int i = 0; i < edges; i++) {
        int src, dest, weight;
        scanf("%d %d %d", &src, &dest, &weight);
        addEdge(&graph, src, dest, weight);
    }

    printAdjList(&graph);
    primMST(&graph);

    return 0;
}

Q40 Write a Program to implement Kruskalâ€™s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency List to represent a graph.
#include <stdio.h>
#include <stdlib.h>

#define MAX 10  // Maximum number of vertices

// Structure to represent an edge
typedef struct Edge {
    int src, dest, weight;
} Edge;

// Structure to represent a subset for union-find
typedef struct Subset {
    int parent, rank;
} Subset;

// Function to find the subset of an element
int find(Subset subsets[], int i) {
    if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent);
    return subsets[i].parent;
}

// Function to perform union of two subsets
void unionSets(Subset subsets[], int x, int y) {
    int rootX = find(subsets, x);
    int rootY = find(subsets, y);

    if (subsets[rootX].rank < subsets[rootY].rank) {
        subsets[rootX].parent = rootY;
    } else if (subsets[rootX].rank > subsets[rootY].rank) {
        subsets[rootY].parent = rootX;
    } else {
        subsets[rootY].parent = rootX;
        subsets[rootX].rank++;
    }
}

// Function to compare two edges based on weight
int compareEdges(const void* a, const void* b) {
    return ((Edge*)a)->weight - ((Edge*)b)->weight;
}

// Kruskal's Algorithm to find MST
void kruskalMST(int graph[MAX][MAX], int vertices) {
    Edge edges[MAX * MAX];
    int edgeCount = 0;

    // Convert the adjacency matrix to an edge list
    for (int i = 0; i < vertices; i++) {
        for (int j = i + 1; j < vertices; j++) {
            if (graph[i][j] != 0) {
                edges[edgeCount].src = i;
                edges[edgeCount].dest = j;
                edges[edgeCount].weight = graph[i][j];
                edgeCount++;
            }
        }
    }

    // Sort all edges in non-decreasing order of weight
    qsort(edges, edgeCount, sizeof(Edge), compareEdges);

    // Create subsets for union-find
    Subset subsets[MAX];
    for (int i = 0; i < vertices; i++) {
        subsets[i].parent = i;
        subsets[i].rank = 0;
    }

    // Process the edges and add them to the MST if they don't form a cycle
    printf("\nMinimum Spanning Tree:\n");
    printf("Edge\tWeight\n");
    for (int i = 0, count = 0; i < edgeCount && count < vertices - 1; i++) {
        int u = edges[i].src;
        int v = edges[i].dest;
        int weight = edges[i].weight;

        int rootU = find(subsets, u);
        int rootV = find(subsets, v);

        if (rootU != rootV) {
            printf("%d - %d\t%d\n", u, v, weight);
            unionSets(subsets, rootU, rootV);
            count++;
        }
    }
}

int main() {
    int graph[MAX][MAX], vertices;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    printf("Enter the adjacency matrix (enter 0 for no edge):\n");
    for (int i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            scanf("%d", &graph[i][j]);
        }
    }

    kruskalMST(graph, vertices);

    return 0;
}

Q41 Write a Program to implement Dijkstraâ€™s algorithm to find shortest distance between two nodes of a user defined graph. Use Adjacency List to represent a graph.
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define MAX 10  // Maximum number of vertices

// Structure to represent a node in the adjacency list
typedef struct Node {
    int vertex;
    int weight;
    struct Node* next;
} Node;

// Structure to represent a graph
typedef struct Graph {
    Node* adjList[MAX];
    int vertices;
} Graph;

// Create a new adjacency list node
Node* createNode(int vertex, int weight) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = vertex;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

// Initialize graph
void initializeGraph(Graph* graph, int vertices) {
    graph->vertices = vertices;
    for (int i = 0; i < vertices; i++) {
        graph->adjList[i] = NULL;
    }
}

// Add an edge to the adjacency list
void addEdge(Graph* graph, int src, int dest, int weight) {
    Node* newNode = createNode(dest, weight);
    newNode->next = graph->adjList[src];
    graph->adjList[src] = newNode;
}

// Function to print the adjacency list
void printAdjList(Graph* graph) {
    printf("\nAdjacency List:\n");
    for (int i = 0; i < graph->vertices; i++) {
        printf("Vertex %d: ", i);
        Node* temp = graph->adjList[i];
        while (temp) {
            printf("-> (%d, %d) ", temp->vertex, temp->weight);
            temp = temp->next;
        }
        printf("\n");
    }
}

// Function to find the vertex with the minimum distance value
int findMinDistance(int dist[], int visited[], int vertices) {
    int min = INT_MAX, minIndex = -1;
    for (int v = 0; v < vertices; v++) {
        if (!visited[v] && dist[v] < min) {
            min = dist[v];
            minIndex = v;
        }
    }
    return minIndex;
}

// Dijkstra's Algorithm
void dijkstra(Graph* graph, int start, int target) {
    int dist[MAX], visited[MAX], parent[MAX];
    int vertices = graph->vertices;

    // Initialize distances, visited array, and parent array
    for (int i = 0; i < vertices; i++) {
        dist[i] = INT_MAX;
        visited[i] = 0;
        parent[i] = -1;
    }

    dist[start] = 0;

    for (int count = 0; count < vertices - 1; count++) {
        int u = findMinDistance(dist, visited, vertices);
        if (u == -1) break;  // No reachable nodes left
        visited[u] = 1;

        // Update dist[] for adjacent vertices
        Node* temp = graph->adjList[u];
        while (temp) {
            int v = temp->vertex;
            int weight = temp->weight;

            if (!visited[v] && dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                parent[v] = u;
            }
            temp = temp->next;
        }
    }

    // Print shortest distance and path
    if (dist[target] == INT_MAX) {
        printf("\nNo path exists between %d and %d.\n", start, target);
    } else {
        printf("\nShortest distance from %d to %d is: %d\n", start, target, dist[target]);
        printf("Path: ");
        int path[MAX], count = 0, current = target;
        while (current != -1) {
            path[count++] = current;
            current = parent[current];
        }
        for (int i = count - 1; i >= 0; i--) {
            printf("%d", path[i]);
            if (i != 0) printf(" -> ");
        }
        printf("\n");
    }
}

int main() {
    Graph graph;
    int vertices, edges;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);
    initializeGraph(&graph, vertices);

    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    printf("Enter the edges in the format (src dest weight):\n");
    for (int i = 0; i < edges; i++) {
        int src, dest, weight;
        scanf("%d %d %d", &src, &dest, &weight);
        addEdge(&graph, src, dest, weight);
    }

    printAdjList(&graph);

    int start, target;
    printf("Enter the starting vertex: ");
    scanf("%d", &start);
    printf("Enter the target vertex: ");
    scanf("%d", &target);

    dijkstra(&graph, start, target);

    return 0;
}
Q42 Write a Program to implement Primâ€™s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency Matrix to represent a graph.
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define MAX 10  // Maximum number of vertices

// Function to find the vertex with the minimum key value that hasn't been included in MST
int minKey(int key[], int mstSet[], int vertices) {
    int min = INT_MAX, minIndex;
    for (int v = 0; v < vertices; v++) {
        if (mstSet[v] == 0 && key[v] < min) {
            min = key[v];
            minIndex = v;
        }
    }
    return minIndex;
}

// Function to implement Primâ€™s algorithm to find the MST
void primMST(int graph[MAX][MAX], int vertices) {
    int parent[MAX];  // Array to store the MST
    int key[MAX];     // Used to pick the minimum weight edge
    int mstSet[MAX];  // To track the vertices included in MST

    // Initialize all keys as INFINITE, mstSet[] as false
    for (int i = 0; i < vertices; i++) {
        key[i] = INT_MAX;
        mstSet[i] = 0;
    }

    // Start from the first vertex
    key[0] = 0;  // First vertex is picked as the starting point
    parent[0] = -1;  // First node has no parent

    // The MST will have exactly vertices - 1 edges
    for (int count = 0; count < vertices - 1; count++) {
        // Pick the minimum key vertex that is not yet included in MST
        int u = minKey(key, mstSet, vertices);
        mstSet[u] = 1;  // Include this vertex in MST

        // Update the key and parent values of the adjacent vertices of the picked vertex
        for (int v = 0; v < vertices; v++) {
            // graph[u][v] is non-zero only for adjacent vertices
            // mstSet[v] is false if v is not yet included in MST
            // Update the key only if the graph[u][v] is smaller than the current key[v]
            if (graph[u][v] && mstSet[v] == 0 && graph[u][v] < key[v]) {
                key[v] = graph[u][v];
                parent[v] = u;
            }
        }
    }

    // Print the MST
    printf("\nMinimum Spanning Tree (MST):\n");
    printf("Edge \tWeight\n");
    for (int i = 1; i < vertices; i++) {
        printf("%d - %d \t%d\n", parent[i], i, graph[i][parent[i]]);
    }
}

int main() {
    int graph[MAX][MAX], vertices;

    // Input the number of vertices
    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    // Input the adjacency matrix
    printf("Enter the adjacency matrix (enter 0 for no edge):\n");
    for (int i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            scanf("%d", &graph[i][j]);
        }
    }

    // Apply Primâ€™s algorithm to find the MST
    primMST(graph, vertices);

    return 0;
}

Q43Implement following collision handling techniques on hash table where Mod hash function is used.
A. Linear Probing
B. Quadratic Probing.
C. Double Hashing.
Also mentioned number of collision occurred in each technique.
#include <stdio.h>
#include <string.h>

#define TABLE_SIZE 10

int hashFunction(int key) {
    return key % TABLE_SIZE;
}

// Linear Probing
void linearProbing(int hashTable[], int key) {
    int index = hashFunction(key);
    int collisions = 0;

    while (hashTable[index] != -1) {
        index = (index + 1) % TABLE_SIZE;
        collisions++;
    }
    hashTable[index] = key;
    printf("Linear Probing: Key = %d, Collisions = %d\n", key, collisions);
}

// Quadratic Probing
void quadraticProbing(int hashTable[], int key) {
    int index = hashFunction(key);
    int i = 0, collisions = 0;

    while (hashTable[(index + i * i) % TABLE_SIZE] != -1) {
        i++;
        collisions++;
    }
    hashTable[(index + i * i) % TABLE_SIZE] = key;
    printf("Quadratic Probing: Key = %d, Collisions = %d\n", key, collisions);
}

// Double Hashing
int secondaryHash(int key) {
    return 7 - (key % 7);
}

void doubleHashing(int hashTable[], int key) {
    int index = hashFunction(key);
    int step = secondaryHash(key);
    int collisions = 0;

    while (hashTable[index] != -1) {
        index = (index + step) % TABLE_SIZE;
        collisions++;
    }
    hashTable[index] = key;
    printf("Double Hashing: Key = %d, Collisions = %d\n", key, collisions);
}

void printTable(int hashTable[]) {
    printf("Hash Table: ");
    for (int i = 0; i < TABLE_SIZE; i++) {
        printf("%d ", hashTable[i]);
    }
    printf("\n");
}

int main() {
    int hashTable[TABLE_SIZE];
    memset(hashTable, -1, sizeof(hashTable));

    int keys[] = {23, 43, 13, 27, 36};
    int n = sizeof(keys) / sizeof(keys[0]);

    printf("Using Linear Probing:\n");
    for (int i = 0; i < n; i++) {
        linearProbing(hashTable, keys[i]);
    }
    printTable(hashTable);

    memset(hashTable, -1, sizeof(hashTable));
    printf("\nUsing Quadratic Probing:\n");
    for (int i = 0; i < n; i++) {
        quadraticProbing(hashTable, keys[i]);
    }
    printTable(hashTable);

    memset(hashTable, -1, sizeof(hashTable));
    printf("\nUsing Double Hashing:\n");
    for (int i = 0; i < n; i++) {
        doubleHashing(hashTable, keys[i]);
    }
    printTable(hashTable);

    return 0;
}

Q44 WAP to implement Bubble sort and Quick Sort on 1D array of Student structure (contains student_name, student_roll_no, total_marks), with key as student_roll_no. And count the number of swap performed.
#include <stdio.h>
#include <string.h>

typedef struct {
    int roll_no;
    char name[20];
    int total_marks;
} Student;

void bubbleSort(Student arr[], int n) {
    int swaps = 0;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j].roll_no > arr[j + 1].roll_no) {
                Student temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swaps++;
            }
        }
    }
    printf("Bubble Sort: Number of swaps = %d\n", swaps);
}

int partition(Student arr[], int low, int high, int *swaps) {
    int pivot = arr[high].roll_no;
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j].roll_no < pivot) {
            i++;
            Student temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            (*swaps)++;
        }
    }
    Student temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    (*swaps)++;
    return i + 1;
}

void quickSort(Student arr[], int low, int high, int *swaps) {
    if (low < high) {
        int pi = partition(arr, low, high, swaps);

        quickSort(arr, low, pi - 1, swaps);
        quickSort(arr, pi + 1, high, swaps);
    }
}

void printStudents(Student arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("Roll No: %d, Name: %s, Marks: %d\n", arr[i].roll_no, arr[i].name, arr[i].total_marks);
    }
}

int main() {
    Student students[] = {
        {101, "Alice", 85},
        {105, "Bob", 90},
        {103, "Charlie", 78},
        {102, "David", 88},
        {104, "Eve", 92}
    };
    int n = sizeof(students) / sizeof(students[0]);

    printf("Original List:\n");
    printStudents(students, n);

    printf("\nSorting using Bubble Sort:\n");
    bubbleSort(students, n);
    printStudents(students, n);

    int swaps = 0;
    printf("\nSorting using Quick Sort:\n");
    quickSort(students, 0, n - 1, &swaps);
    printf("Quick Sort: Number of swaps = %d\n", swaps);
    printStudents(students, n);

    return 0;
}

Q45 WAP to implement Insertion sort and Merge Sort on 1D array of Student structure (contains student_name, student_roll_no, total_marks), with key as student_roll_no. And count the number of swap performed.
#include <stdio.h>
#include <string.h>

typedef struct {
    char name[20];
    int roll_no;
    int marks;
} Student;

void insertionSort(Student arr[], int n) {
    int swaps = 0;
    for (int i = 1; i < n; i++) {
        Student key = arr[i];
        int j = i - 1;

        while (j >= 0 && arr[j].roll_no > key.roll_no) {
            arr[j + 1] = arr[j];
            j--;
            swaps++;
        }
        arr[j + 1] = key;
    }
    printf("Insertion Sort: Swaps = %d\n", swaps);
}

void merge(Student arr[], int l, int m, int r, int *swaps) {
    int n1 = m - l + 1, n2 = r - m;
    Student L[n1], R[n2];

    for (int i = 0; i < n1; i++) L[i] = arr[l + i];
    for (int i = 0; i < n2; i++) R[i] = arr[m + 1 + i];

    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (L[i].roll_no <= R[j].roll_no)
            arr[k++] = L[i++];
        else {
            arr[k++] = R[j++];
            (*swaps)++;
        }
    }
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

void mergeSort(Student arr[], int l, int r, int *swaps) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m, swaps);
        mergeSort(arr, m + 1, r, swaps);
        merge(arr, l, m, r, swaps);
    }
}

void printStudents(Student arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("Roll No: %d, Name: %s, Marks: %d\n", arr[i].roll_no, arr[i].name, arr[i].marks);
    }
}

int main() {
    Student students[] = {
        {"Alice", 3, 85}, {"Bob", 1, 90}, {"Charlie", 2, 78}
    };
    int n = sizeof(students) / sizeof(students[0]);

    printf("Original List:\n");
    printStudents(students, n);

    printf("\nUsing Insertion Sort:\n");
    insertionSort(students, n);
    printStudents(students, n);

    printf("\nUsing Merge Sort:\n");
    int swaps = 0;
    mergeSort(students, 0, n - 1, &swaps);
    printf("Merge Sort: Swaps = %d\n", swaps);
    printStudents(students, n);

    return 0;
}

Q46 WAP to implement Selection sort and Bubble Sort on 1D array of Employee structure (contains employee_name, emp_no, 
emp_salary), with key as emp_no. And count the number of swap performed.
#include <stdio.h>
#include <string.h>

typedef struct {
    char name[20];
    int emp_no;
    float salary;
} Employee;

void selectionSort(Employee arr[], int n) {
    int swaps = 0;
    for (int i = 0; i < n - 1; i++) {
        int min_idx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j].emp_no < arr[min_idx].emp_no)
                min_idx = j;
        }
        if (min_idx != i) {
            Employee temp = arr[i];
            arr[i] = arr[min_idx];
            arr[min_idx] = temp;
            swaps++;
        }
    }
    printf("Selection Sort: Swaps = %d\n", swaps);
}

void bubbleSort(Employee arr[], int n) {
    int swaps = 0;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j].emp_no > arr[j + 1].emp_no) {
                Employee temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swaps++;
            }
        }
    }
    printf("Bubble Sort: Swaps = %d\n", swaps);
}

void printEmployees(Employee arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("Emp No: %d, Name: %s, Salary: %.2f\n", arr[i].emp_no, arr[i].name, arr[i].salary);
    }
}

int main() {
    Employee employees[] = {
        {"John", 105, 45000}, {"Jane", 101, 55000}, {"Doe", 103, 40000}
    };
    int n = sizeof(employees) / sizeof(employees[0]);

    printf("Original List:\n");
    printEmployees(employees, n);

    printf("\nUsing Selection Sort:\n");
    selectionSort(employees, n);
    printEmployees(employees, n);

    printf("\nUsing Bubble Sort:\n");
    bubbleSort(employees, n);
    printEmployees(employees, n);

    return 0;
}

Q47 WAP to implement Quick sort and Heap Sort on 1D array of Employee structure (contains employee_name, emp_no, 
emp_salary), with key as emp_no. And count the number of swap performed.
#include <stdio.h>
#include <string.h>

typedef struct {
    char name[20];
    int emp_no;
    float salary;
} Employee;

void quickSort(Employee arr[], int low, int high, int *swaps) {
    if (low < high) {
        int pivot = arr[high].emp_no;
        int i = low - 1;

        for (int j = low; j < high; j++) {
            if (arr[j].emp_no < pivot) {
                i++;
                Employee temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                (*swaps)++;
            }
        }
        Employee temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        (*swaps)++;

        int pi = i + 1;

        quickSort(arr, low, pi - 1, swaps);
        quickSort(arr, pi + 1, high, swaps);
    }
}

void heapify(Employee arr[], int n, int i, int *swaps) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left].emp_no > arr[largest].emp_no)
        largest = left;

    if (right < n && arr[right].emp_no > arr[largest].emp_no)
        largest = right;

    if (largest != i) {
        Employee temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;
        (*swaps)++;

        heapify(arr, n, largest, swaps);
    }
}

void heapSort(Employee arr[], int n, int *swaps) {
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i, swaps);

    for (int i = n - 1; i > 0; i--) {
        Employee temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        (*swaps)++;

        heapify(arr, i, 0, swaps);
    }
}

void printEmployees(Employee arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("Emp No: %d, Name: %s, Salary: %.2f\n", arr[i].emp_no, arr[i].name, arr[i].salary);
    }
}

int main() {
    Employee employees[] = {
        {"John", 105, 45000}, {"Jane", 101, 55000}, {"Doe", 103, 40000}
    };
    int n = sizeof(employees) / sizeof(employees[0]);

    printf("Original List:\n");
    printEmployees(employees, n);

    printf("\nUsing Quick Sort:\n");
    int swaps = 0;
    quickSort(employees, 0, n - 1, &swaps);
    printf("Quick Sort: Swaps = %d\n", swaps);
    printEmployees(employees, n);

    printf("\nUsing Heap Sort:\n");
    swaps = 0;
    heapSort(employees, n, &swaps);
    printf("Heap Sort: Swaps = %d\n", swaps);
    printEmployees(employees, n);

    return 0;
}

Q48WAP to implement Insertion sort and Quick Sort on 1D array of Student structure (contains student_name, student_roll_no, total_marks), with key as student_roll_no. And count the number of swap performed.
#include <stdio.h>
#include <string.h>

// Define the structure for Student
typedef struct {
    char student_name[50];
    int student_roll_no;
    float total_marks;
} Student;

// Function to swap two students
void swap(Student *a, Student *b) {
    Student temp = *a;
    *a = *b;
    *b = temp;
}

// Insertion Sort Function
int insertionSort(Student arr[], int n) {
    int swapCount = 0;
    for (int i = 1; i < n; i++) {
        Student key = arr[i];
        int j = i - 1;

        // Move elements greater than key to one position ahead
        while (j >= 0 && arr[j].student_roll_no > key.student_roll_no) {
            arr[j + 1] = arr[j];
            j--;
            swapCount++;
        }
        arr[j + 1] = key;
    }
    return swapCount;
}

// Partition function for Quick Sort
int partition(Student arr[], int low, int high, int *swapCount) {
    int pivot = arr[high].student_roll_no; // Pivot is the last element
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j].student_roll_no <= pivot) {
            i++;
            swap(&arr[i], &arr[j]);
            (*swapCount)++;
        }
    }
    swap(&arr[i + 1], &arr[high]);
    (*swapCount)++;
    return i + 1;
}

// Quick Sort Function
void quickSort(Student arr[], int low, int high, int *swapCount) {
    if (low < high) {
        int pi = partition(arr, low, high, swapCount);
        quickSort(arr, low, pi - 1, swapCount);
        quickSort(arr, pi + 1, high, swapCount);
    }
}

// Function to print the array of students
void printStudents(Student arr[], int n) {
    printf("\n%-20s %-10s %-10s\n", "Name", "Roll No", "Marks");
    for (int i = 0; i < n; i++) {
        printf("%-20s %-10d %-10.2f\n", arr[i].student_name, arr[i].student_roll_no, arr[i].total_marks);
    }
}

// Main Function
int main() {
    Student students[] = {
        {"Alice", 3, 85.5},
        {"Bob", 1, 90.0},
        {"Charlie", 2, 75.5},
        {"Diana", 4, 88.0}
    };
    int n = sizeof(students) / sizeof(students[0]);

    printf("Original List of Students:");
    printStudents(students, n);

    // Insertion Sort
    Student students1[n];
    memcpy(students1, students, sizeof(students));
    int insertionSwapCount = insertionSort(students1, n);
    printf("\nAfter Insertion Sort:");
    printStudents(students1, n);
    printf("Insertion Sort Swap Count: %d\n", insertionSwapCount);

    // Quick Sort
    Student students2[n];
    memcpy(students2, students, sizeof(students));
    int quickSortSwapCount = 0;
    quickSort(students2, 0, n - 1, &quickSortSwapCount);
    printf("\nAfter Quick Sort:");
    printStudents(students2, n);
    printf("Quick Sort Swap Count: %d\n", quickSortSwapCount);

    return 0;
}



Q49 WAP to implement Selection sort and Merge Sort on 1D array of Student structure (contains student_name, student_roll_no, total_marks), with key as student_roll_no. And count the number of swap performed.
#include <stdio.h>
#include <string.h>

// Define the Student structure
typedef struct {
    char student_name[50];
    int student_roll_no;
    float total_marks;
} Student;

// Function to swap two students
void swap(Student *a, Student *b) {
    Student temp = *a;
    *a = *b;
    *b = temp;
}

// Selection Sort Function
int selectionSort(Student arr[], int n) {
    int swapCount = 0;
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j].student_roll_no < arr[minIdx].student_roll_no) {
                minIdx = j;
            }
        }
        if (minIdx != i) {
            swap(&arr[i], &arr[minIdx]);
            swapCount++;
        }
    }
    return swapCount;
}

// Merge function for Merge Sort
void merge(Student arr[], int left, int mid, int right, int *swapCount) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    Student L[n1], R[n2];
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int i = 0; i < n2; i++)
        R[i] = arr[mid + 1 + i];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i].student_roll_no <= R[j].student_roll_no) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
            (*swapCount)++; // Count swaps when merging
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// Merge Sort Function
void mergeSort(Student arr[], int left, int right, int *swapCount) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid, swapCount);
        mergeSort(arr, mid + 1, right, swapCount);
        merge(arr, left, mid, right, swapCount);
    }
}

// Function to print the array of students
void printStudents(Student arr[], int n) {
    printf("\n%-20s %-10s %-10s\n", "Name", "Roll No", "Marks");
    for (int i = 0; i < n; i++) {
        printf("%-20s %-10d %-10.2f\n", arr[i].student_name, arr[i].student_roll_no, arr[i].total_marks);
    }
}

// Main Function
int main() {
    Student students[] = {
        {"Alice", 5, 85.5},
        {"Bob", 2, 90.0},
        {"Charlie", 4, 75.5},
        {"Diana", 3, 88.0},
        {"Eve", 1, 92.0}
    };
    int n = sizeof(students) / sizeof(students[0]);

    printf("Original List of Students:");
    printStudents(students, n);

    // Selection Sort
    Student students1[n];
    memcpy(students1, students, sizeof(students));
    int selectionSwapCount = selectionSort(students1, n);
    printf("\nAfter Selection Sort:");
    printStudents(students1, n);
    printf("Selection Sort Swap Count: %d\n", selectionSwapCount);

    // Merge Sort
    Student students2[n];
    memcpy(students2, students, sizeof(students));
    int mergeSortSwapCount = 0;
    mergeSort(students2, 0, n - 1, &mergeSortSwapCount);
    printf("\nAfter Merge Sort:");
    printStudents(students2, n);
    printf("Merge Sort Swap Count: %d\n", mergeSortSwapCount);

    return 0;
}



Q50WAP to implement Heap and Quick Sort on 1D array of Employee structure (contains employee_name, emp_no, emp_salary), with key as emp_no. And count the number of swap performed.
#include <stdio.h>
#include <string.h>

// Define the Employee structure
typedef struct {
    char employee_name[50];
    int emp_no;
    float emp_salary;
} Employee;

// Function to swap two employees
void swap(Employee *a, Employee *b) {
    Employee temp = *a;
    *a = *b;
    *b = temp;
}

// Heapify function for Heap Sort
void heapify(Employee arr[], int n, int i, int *swapCount) {
    int largest = i;        // Initialize largest as root
    int left = 2 * i + 1;   // Left child
    int right = 2 * i + 2;  // Right child

    if (left < n && arr[left].emp_no > arr[largest].emp_no)
        largest = left;

    if (right < n && arr[right].emp_no > arr[largest].emp_no)
        largest = right;

    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        (*swapCount)++;
        heapify(arr, n, largest, swapCount);
    }
}

// Heap Sort function
int heapSort(Employee arr[], int n) {
    int swapCount = 0;

    // Build the heap
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i, &swapCount);

    // Extract elements from the heap
    for (int i = n - 1; i >= 0; i--) {
        swap(&arr[0], &arr[i]);
        swapCount++;
        heapify(arr, i, 0, &swapCount);
    }

    return swapCount;
}

// Partition function for Quick Sort
int partition(Employee arr[], int low, int high, int *swapCount) {
    int pivot = arr[high].emp_no; // Pivot is the last element
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j].emp_no <= pivot) {
            i++;
            swap(&arr[i], &arr[j]);
            (*swapCount)++;
        }
    }
    swap(&arr[i + 1], &arr[high]);
    (*swapCount)++;
    return i + 1;
}

// Quick Sort function
void quickSort(Employee arr[], int low, int high, int *swapCount) {
    if (low < high) {
        int pi = partition(arr, low, high, swapCount);
        quickSort(arr, low, pi - 1, swapCount);
        quickSort(arr, pi + 1, high, swapCount);
    }
}

// Function to print the array of employees
void printEmployees(Employee arr[], int n) {
    printf("\n%-20s %-10s %-10s\n", "Name", "Emp No", "Salary");
    for (int i = 0; i < n; i++) {
        printf("%-20s %-10d %-10.2f\n", arr[i].employee_name, arr[i].emp_no, arr[i].emp_salary);
    }
}

// Main function
int main() {
    Employee employees[] = {
        {"Alice", 105, 50000},
        {"Bob", 101, 60000},
        {"Charlie", 103, 55000},
        {"Diana", 104, 52000},
        {"Eve", 102, 58000}
    };
    int n = sizeof(employees) / sizeof(employees[0]);

    printf("Original List of Employees:");
    printEmployees(employees, n);

    // Heap Sort
    Employee employees1[n];
    memcpy(employees1, employees, sizeof(employees));
    int heapSortSwapCount = heapSort(employees1, n);
    printf("\nAfter Heap Sort:");
    printEmployees(employees1, n);
    printf("Heap Sort Swap Count: %d\n", heapSortSwapCount);

    // Quick Sort
    Employee employees2[n];
    memcpy(employees2, employees, sizeof(employees));
    int quickSortSwapCount = 0;
    quickSort(employees2, 0, n - 1, &quickSortSwapCount);
    printf("\nAfter Quick Sort:");
    printEmployees(employees2, n);
    printf("Quick Sort Swap Count: %d\n", quickSortSwapCount);

    return 0;
}


Q51 WAP to implement Bubble sort and Heap Sort on 1D array of Employee structure (contains employee_name, emp_no, 
emp_salary), with key as emp_no. And count the number of swap performed.
#include <stdio.h>
#include <string.h>

// Define the Employee structure
typedef struct {
    char employee_name[50];
    int emp_no;
    float emp_salary;
} Employee;

// Function to swap two Employee records
void swap(Employee *a, Employee *b) {
    Employee temp = *a;
    *a = *b;
    *b = temp;
}

// Bubble Sort function
int bubbleSort(Employee arr[], int n) {
    int swapCount = 0;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j].emp_no > arr[j + 1].emp_no) {
                swap(&arr[j], &arr[j + 1]);
                swapCount++;
            }
        }
    }
    return swapCount;
}

// Heapify function for Heap Sort
void heapify(Employee arr[], int n, int i, int *swapCount) {
    int largest = i;         // Initialize largest as root
    int left = 2 * i + 1;    // Left child
    int right = 2 * i + 2;   // Right child

    if (left < n && arr[left].emp_no > arr[largest].emp_no)
        largest = left;

    if (right < n && arr[right].emp_no > arr[largest].emp_no)
        largest = right;

    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        (*swapCount)++;
        heapify(arr, n, largest, swapCount);
    }
}

// Heap Sort function
int heapSort(Employee arr[], int n) {
    int swapCount = 0;

    // Build a max heap
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i, &swapCount);

    // Extract elements from the heap
    for (int i = n - 1; i >= 0; i--) {
        swap(&arr[0], &arr[i]);
        swapCount++;
        heapify(arr, i, 0, &swapCount);
    }

    return swapCount;
}

// Function to print the Employee array
void printEmployees(Employee arr[], int n) {
    printf("\n%-20s %-10s %-10s\n", "Name", "Emp No", "Salary");
    for (int i = 0; i < n; i++) {
        printf("%-20s %-10d %-10.2f\n", arr[i].employee_name, arr[i].emp_no, arr[i].emp_salary);
    }
}

// Main function
int main() {
    Employee employees[] = {
        {"Alice", 105, 50000},
        {"Bob", 101, 60000},
        {"Charlie", 103, 55000},
        {"Diana", 104, 52000},
        {"Eve", 102, 58000}
    };
    int n = sizeof(employees) / sizeof(employees[0]);

    printf("Original List of Employees:");
    printEmployees(employees, n);

    // Bubble Sort
    Employee employees1[n];
    memcpy(employees1, employees, sizeof(employees));
    int bubbleSortSwapCount = bubbleSort(employees1, n);
    printf("\nAfter Bubble Sort:");
    printEmployees(employees1, n);
    printf("Bubble Sort Swap Count: %d\n", bubbleSortSwapCount);

    // Heap Sort
    Employee employees2[n];
    memcpy(employees2, employees, sizeof(employees));
    int heapSortSwapCount = heapSort(employees2, n);
    printf("\nAfter Heap Sort:");
    printEmployees(employees2, n);
    printf("Heap Sort Swap Count: %d\n", heapSortSwapCount);

    return 0;
}



Q52 WAP to implement Merge Sort and Quick sort on 1D array of Faculty structure (contains faculty_name, faculty_ID, 
subject_codes, class_names), with key as faculty_ID. And count the number of swap performed
#include <stdio.h>
#include <string.h>

// Define the Faculty structure
typedef struct {
    char faculty_name[50];
    int faculty_ID;
    char subject_codes[100];
    char class_names[100];
} Faculty;

// Function to swap two Faculty records
void swap(Faculty *a, Faculty *b, int *swapCount) {
    Faculty temp = *a;
    *a = *b;
    *b = temp;
    (*swapCount)++;
}

// Merge Sort - Merge function
void merge(Faculty arr[], int left, int mid, int right, int *swapCount) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // Create temporary arrays
    Faculty L[n1], R[n2];
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int i = 0; i < n2; i++)
        R[i] = arr[mid + 1 + i];

    // Merge temporary arrays back into arr
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i].faculty_ID <= R[j].faculty_ID) {
            arr[k++] = L[i++];
        } else {
            arr[k++] = R[j++];
            (*swapCount)++;
        }
    }

    // Copy remaining elements
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

// Merge Sort function
void mergeSort(Faculty arr[], int left, int right, int *swapCount) {
    if (left < right) {
        int mid = left + (right - left) / 2;

        // Sort first and second halves
        mergeSort(arr, left, mid, swapCount);
        mergeSort(arr, mid + 1, right, swapCount);

        // Merge sorted halves
        merge(arr, left, mid, right, swapCount);
    }
}

// Quick Sort - Partition function
int partition(Faculty arr[], int low, int high, int *swapCount) {
    int pivot = arr[high].faculty_ID;
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j].faculty_ID < pivot) {
            i++;
            swap(&arr[i], &arr[j], swapCount);
        }
    }
    swap(&arr[i + 1], &arr[high], swapCount);
    return i + 1;
}

// Quick Sort function
void quickSort(Faculty arr[], int low, int high, int *swapCount) {
    if (low < high) {
        int pi = partition(arr, low, high, swapCount);

        // Sort elements before and after partition
        quickSort(arr, low, pi - 1, swapCount);
        quickSort(arr, pi + 1, high, swapCount);
    }
}

// Function to print Faculty array
void printFaculty(Faculty arr[], int n) {
    printf("\n%-20s %-10s %-20s %-20s\n", "Name", "ID", "Subjects", "Classes");
    for (int i = 0; i < n; i++) {
        printf("%-20s %-10d %-20s %-20s\n", arr[i].faculty_name, arr[i].faculty_ID, arr[i].subject_codes, arr[i].class_names);
    }
}

// Main function
int main() {
    Faculty faculties[] = {
        {"Dr. Alice", 105, "CS101", "CSE-A"},
        {"Dr. Bob", 101, "CS102", "CSE-B"},
        {"Dr. Charlie", 103, "CS103", "CSE-C"},
        {"Dr. Diana", 104, "CS104", "CSE-D"},
        {"Dr. Eve", 102, "CS105", "CSE-E"}
    };
    int n = sizeof(faculties) / sizeof(faculties[0]);

    printf("Original List of Faculties:");
    printFaculty(faculties, n);

    // Merge Sort
    Faculty mergeSorted[n];
    memcpy(mergeSorted, faculties, sizeof(faculties));
    int mergeSortSwapCount = 0;
    mergeSort(mergeSorted, 0, n - 1, &mergeSortSwapCount);
    printf("\nAfter Merge Sort:");
    printFaculty(mergeSorted, n);
    printf("Merge Sort Swap Count: %d\n", mergeSortSwapCount);

    // Quick Sort
    Faculty quickSorted[n];
    memcpy(quickSorted, faculties, sizeof(faculties));
    int quickSortSwapCount = 0;
    quickSort(quickSorted, 0, n - 1, &quickSortSwapCount);
    printf("\nAfter Quick Sort:");
    printFaculty(quickSorted, n);
    printf("Quick Sort Swap Count: %d\n", quickSortSwapCount);

    return 0;
}



Q53 WAP to implement Merge Sort and Heap Sort on 1D array of Faculty structure (contains faculty_name, faculty_ID, 
subject_codes, class_names), with key as faculty_ID. And count the number of swap performed.
#include <stdio.h>
#include <string.h>

// Define the Faculty structure
typedef struct {
    char faculty_name[50];
    int faculty_ID;
    char subject_codes[100];
    char class_names[100];
} Faculty;

// Swap function to swap two elements and count swaps
void swap(Faculty *a, Faculty *b, int *swapCount) {
    Faculty temp = *a;
    *a = *b;
    *b = temp;
    (*swapCount)++;
}

// Merge Sort - Merge function
void merge(Faculty arr[], int left, int mid, int right, int *swapCount) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // Create temporary arrays
    Faculty L[n1], R[n2];
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int i = 0; i < n2; i++)
        R[i] = arr[mid + 1 + i];

    // Merge temporary arrays back into arr
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i].faculty_ID <= R[j].faculty_ID) {
            arr[k++] = L[i++];
        } else {
            arr[k++] = R[j++];
            (*swapCount)++;
        }
    }

    // Copy remaining elements
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

// Merge Sort function
void mergeSort(Faculty arr[], int left, int right, int *swapCount) {
    if (left < right) {
        int mid = left + (right - left) / 2;

        // Sort first and second halves
        mergeSort(arr, left, mid, swapCount);
        mergeSort(arr, mid + 1, right, swapCount);

        // Merge sorted halves
        merge(arr, left, mid, right, swapCount);
    }
}

// Heap Sort - Heapify function to maintain heap property
void heapify(Faculty arr[], int n, int i, int *swapCount) {
    int largest = i; // Initialize largest as root
    int left = 2 * i + 1; // Left child
    int right = 2 * i + 2; // Right child

    // If left child is larger than root
    if (left < n && arr[left].faculty_ID > arr[largest].faculty_ID) {
        largest = left;
    }

    // If right child is larger than root
    if (right < n && arr[right].faculty_ID > arr[largest].faculty_ID) {
        largest = right;
    }

    // If largest is not root
    if (largest != i) {
        swap(&arr[i], &arr[largest], swapCount);

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest, swapCount);
    }
}

// Heap Sort function
void heapSort(Faculty arr[], int n, int *swapCount) {
    // Build max heap
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i, swapCount);
    }

    // One by one extract elements from heap
    for (int i = n - 1; i > 0; i--) {
        swap(&arr[0], &arr[i], swapCount);

        // Heapify the root element
        heapify(arr, i, 0, swapCount);
    }
}

// Function to print Faculty array
void printFaculty(Faculty arr[], int n) {
    printf("\n%-20s %-10s %-20s %-20s\n", "Name", "ID", "Subjects", "Classes");
    for (int i = 0; i < n; i++) {
        printf("%-20s %-10d %-20s %-20s\n", arr[i].faculty_name, arr[i].faculty_ID, arr[i].subject_codes, arr[i].class_names);
    }
}

// Main function
int main() {
    Faculty faculties[] = {
        {"Dr. Alice", 105, "CS101", "CSE-A"},
        {"Dr. Bob", 101, "CS102", "CSE-B"},
        {"Dr. Charlie", 103, "CS103", "CSE-C"},
        {"Dr. Diana", 104, "CS104", "CSE-D"},
        {"Dr. Eve", 102, "CS105", "CSE-E"}
    };
    int n = sizeof(faculties) / sizeof(faculties[0]);

    printf("Original List of Faculties:");
    printFaculty(faculties, n);

    // Merge Sort
    Faculty mergeSorted[n];
    memcpy(mergeSorted, faculties, sizeof(faculties));
    int mergeSortSwapCount = 0;
    mergeSort(mergeSorted, 0, n - 1, &mergeSortSwapCount);
    printf("\nAfter Merge Sort:");
    printFaculty(mergeSorted, n);
    printf("Merge Sort Swap Count: %d\n", mergeSortSwapCount);

    // Heap Sort
    Faculty heapSorted[n];
    memcpy(heapSorted, faculties, sizeof(faculties));
    int heapSortSwapCount = 0;
    heapSort(heapSorted, n, &heapSortSwapCount);
    printf("\nAfter Heap Sort:");
    printFaculty(heapSorted, n);
    printf("Heap Sort Swap Count: %d\n", heapSortSwapCount);

    return 0;
}



Q54 Assume that an array A with n elements was sorted in an ascending order, but two of its elements swapped their positions by a mistake while maintaining the array. Write a code to identify the swapped pair of elements and their positions in the asymptotically best possible time. [Assume that all given elements are distinct integers.]
#include <stdio.h>

// Function to find the swapped pair in a nearly sorted array
void findSwappedElements(int A[], int n) {
    int first = -1, second = -1;
    
    // Step 1: Find the first element out of order
    for (int i = 0; i < n - 1; i++) {
        if (A[i] > A[i + 1]) {
            first = i;
            break;
        }
    }

    // Step 2: Find the second element out of order (from the end)
    for (int i = n - 1; i > 0; i--) {
        if (A[i] < A[i - 1]) {
            second = i;
            break;
        }
    }

    // If no swapped elements found, the array is already sorted
    if (first == -1 || second == -1) {
        printf("No swapped elements found, the array is sorted.\n");
    } else {
        printf("The swapped elements are %d and %d\n", A[first], A[second]);
        printf("Their positions are: %d and %d\n", first + 1, second + 1);  // 1-based index
    }
}

int main() {
    // Example array where two elements are swapped
    int A[] = {1, 2, 6, 4, 5, 3};
    int n = sizeof(A) / sizeof(A[0]);

    printf("Array before finding the swapped elements:\n");
    for (int i = 0; i < n; i++) {
        printf("%d ", A[i]);
    }
    printf("\n");

    // Call the function to find the swapped pair
    findSwappedElements(A, n);

    return 0;
}



Q55 Arrange the list of employees as per the average of their height and weight by using appropriate sorting method.
#include <stdio.h>
#include <string.h>

// Employee structure containing name, height, and weight
typedef struct {
    char employee_name[100];
    float height;  // height in centimeters
    float weight;  // weight in kilograms
    float avg;     // average of height and weight
} Employee;

// Function to calculate the average of height and weight
void calculateAvg(Employee* emp) {
    emp->avg = (emp->height + emp->weight) / 2;
}

// Merge function to merge two halves of the array
void merge(Employee arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    Employee leftArr[n1], rightArr[n2];

    for (int i = 0; i < n1; i++)
        leftArr[i] = arr[left + i];
    for (int i = 0; i < n2; i++)
        rightArr[i] = arr[mid + 1 + i];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (leftArr[i].avg <= rightArr[j].avg) {
            arr[k++] = leftArr[i++];
        } else {
            arr[k++] = rightArr[j++];
        }
    }

    while (i < n1) {
        arr[k++] = leftArr[i++];
    }
    while (j < n2) {
        arr[k++] = rightArr[j++];
    }
}

// Merge Sort function
void mergeSort(Employee arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;

        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        merge(arr, left, mid, right);
    }
}

// Function to print employee details
void printEmployees(Employee arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("Name: %s, Height: %.2f cm, Weight: %.2f kg, Average: %.2f\n",
               arr[i].employee_name, arr[i].height, arr[i].weight, arr[i].avg);
    }
}

int main() {
    // Array of employees
    Employee employees[] = {
        {"John Doe", 175.5, 70.2},
        {"Jane Smith", 160.0, 55.5},
        {"Alice Johnson", 165.3, 60.0},
        {"Bob Brown", 180.2, 80.0}
    };
    int n = sizeof(employees) / sizeof(employees[0]);

    // Calculate average for each employee
    for (int i = 0; i < n; i++) {
        calculateAvg(&employees[i]);
    }

    // Sort employees by the average of height and weight
    mergeSort(employees, 0, n - 1);

    // Print sorted employee details
    printf("Employees sorted by average of height and weight:\n");
    printEmployees(employees, n);

    return 0;
}

BASIC CODES : 
LINKED LIST CREATION, DELETION AND INSERTION -
#include <stdio.h>
#include <stdlib.h>

struct node {
    int data;
    struct node* next;
};

// Function to create a linked list
struct node* create(int n) {
    int value;
    struct node *head, *ptr;
    printf("Enter the node 1: ");
    scanf("%d", &value);
    head = (struct node*)malloc(sizeof(struct node));
    head->data = value;
    head->next = NULL;
    ptr = head;

    for (int i = 2; i <= n; i++) {
        printf("Enter the node %d: ", i);
        ptr->next = (struct node*)malloc(sizeof(struct node));
        ptr = ptr->next;
        scanf("%d", &ptr->data);
        ptr->next = NULL;
    }

    return head;
}

// Function to display the linked list
void display(struct node* head) {
    struct node* ptr = head;
    while (ptr != NULL) {
        printf("%d\t", ptr->data);
        ptr = ptr->next;
    }
    printf("\n");
}

// Function to insert a node at a given index
struct node* InsertAtIndex(int index, struct node* head, int value) {
    struct node* new = (struct node*)malloc(sizeof(struct node));
    new->data = value;

    if (index == 1) { // Insert at the beginning
        new->next = head;
        head = new;
        return head;
    }

    struct node* ptr = head;
    for (int i = 1; i < index - 1 && ptr != NULL; i++) {
        ptr = ptr->next;
    }

    if (ptr == NULL) {
        printf("INVALID INDEX\n");
        free(new); // Free allocated memory for the new node
    } else {
        new->next = ptr->next;
        ptr->next = new;
    }
    return head;
}

// Function to delete a node at a given index
struct node* deleteNode(int index, struct node* head) {
    if (head == NULL) {
        printf("List is empty!\n");
        return head;
    }

    struct node* ptr = head;

    if (index == 1) { // Delete the first node
        head = ptr->next;
        free(ptr);
        return head;
    }

    for (int i = 1; i < index - 1 && ptr != NULL; i++) {
        ptr = ptr->next;
    }

    if (ptr == NULL || ptr->next == NULL) {
        printf("INVALID INDEX\n");
    } else {
        struct node* temp = ptr->next;
        ptr->next = temp->next;
        free(temp);
    }

    return head;
}

int main() {
    int n, index, value;
    struct node* head;

    // Create the linked list
    printf("Enter the number of nodes: ");
    scanf("%d", &n);
    head = create(n);

    // Display the original list
    printf("Original list:\n");
    display(head);

    // Insert at a specific index
    printf("Enter the Index for insertion: ");
    scanf("%d", &index);
    printf("Enter the Value for insertion: ");
    scanf("%d", &value);
    head = InsertAtIndex(index, head, value);

    // Display the updated list
    printf("List after insertion:\n");
    display(head);

    // Delete a node at a specific index
    printf("Enter the index where the node should be deleted: ");
    scanf("%d", &index);
    head = deleteNode(index, head);

    // Display the updated list
    printf("List after deletion:\n");
    display(head);

    return 0;
}

DOUBLY LINKED LIST CREATION AND INSERTION : 
#include <stdio.h>
#include <stdlib.h>

// Node structure
struct node {
    int data;
    struct node* next;
    struct node* prev;
};

// Function to create a doubly linked list
struct node* create(int n) {
    int value;
    struct node *head, *ptr;

    // Input for the first node
    printf("Enter the node 1: ");
    scanf("%d", &value);

    // Create the first node
    head = (struct node*)malloc(sizeof(struct node));
    head->data = value;
    head->next = NULL;
    head->prev = NULL;
    ptr = head;

    // Create the remaining nodes
    for (int i = 2; i <= n; i++) {
        printf("Enter the node %d: ", i);
        struct node* temp = (struct node*)malloc(sizeof(struct node));
        scanf("%d", &temp->data);
        temp->next = NULL;
        temp->prev = ptr;
        ptr->next = temp;
        ptr = temp;
    }

    return head;  // Return the head pointer
}

// Function to display the doubly linked list
void display(struct node* head) {
    struct node* ptr = head;
    while (ptr != NULL) {
        printf("%d\t", ptr->data);
        ptr = ptr->next;
    }
    printf("\n");
}

// Function to insert a node at a given position
struct node* insert(struct node* head, int position) {
    int value;
    struct node* new_node = (struct node*)malloc(sizeof(struct node));

    printf("Enter data for the new node: ");
    scanf("%d", &value);
    new_node->data = value;

    if (position == 1) { // Insert at the beginning
        new_node->next = head;
        new_node->prev = NULL;
        if (head != NULL) {
            head->prev = new_node;
        }
        head = new_node;
        return head;
    }

    struct node* ptr = head;
    for (int i = 1; i < position - 1 && ptr != NULL; i++) {
        ptr = ptr->next;
    }

    if (ptr == NULL) {
        printf("Invalid position!\n");
        free(new_node);
        return head;
    }

    new_node->next = ptr->next;
    new_node->prev = ptr;
    if (ptr->next != NULL) {
        ptr->next->prev = new_node;
    }
    ptr->next = new_node;

    return head;
}

int main() {
    int n, position;
    struct node* head;

    // Input the number of nodes
    printf("Enter the number of nodes: ");
    scanf("%d", &n);

    // Create the doubly linked list
    head = create(n);

    // Display the original list
    printf("Original list:\n");
    display(head);

    // Insert a node at a specified position
    printf("Enter the position at which the new node should be inserted: ");
    scanf("%d", &position);
    head = insert(head, position);

    // Display the updated list
    printf("Updated list:\n");
    display(head);

    return 0;
}

STACK PUSH POP : 
#include <stdio.h>
#include <stdlib.h>

// Stack structure definition
struct stack {
    int top;
    int size;
    int *arr;
};

// Function to check if the stack is empty
int isEmpty(struct stack *ptr) {
    return ptr->top == -1;
}

// Function to check if the stack is full
int isFull(struct stack *ptr) {
    return ptr->top == ptr->size - 1;
}

// Function to push a value onto the stack
void push(struct stack *ptr, int val) {
    if (isFull(ptr)) {
        printf("Stack Overflow! Cannot push %d\n", val);
    } else {
        ptr->top++;
        ptr->arr[ptr->top] = val;
        printf("Pushed %d onto the stack\n", val);
    }
}

// Function to pop a value from the stack
int pop(struct stack *ptr) {
    if (isEmpty(ptr)) {
        printf("Stack Underflow! Cannot pop\n");
        return -1; // Return error code
    } else {
        int temp = ptr->arr[ptr->top];
        ptr->top--;
        return temp;
    }
}

// Main function
int main() {
    struct stack *sp = (struct stack *)malloc(sizeof(struct stack));

    printf("Enter the size of the stack: ");
    scanf("%d", &sp->size);

    // Allocate memory for the stack array
    sp->arr = (int *)malloc(sp->size * sizeof(int));
    sp->top = -1;

    int val, num;

    // Push multiple values onto the stack
    printf("Enter the number of values to be pushed: ");
    scanf("%d", &num);

    if (num > sp->size) {
        printf("Cannot push %d values, stack size is %d.\n", num, sp->size);
    } else {
        for (int i = 1; i <= num; i++) {
            printf("Enter value %d to be pushed: ", i);
            scanf("%d", &val);
            push(sp, val);
        }
    }

    // Pop multiple values from the stack
    printf("Enter the number of values to be popped: ");
    scanf("%d", &num);

    if (num > sp->top + 1) {
        printf("Cannot pop %d values, only %d values are in the stack.\n", num, sp->top + 1);
    } else {
        for (int i = 1; i <= num; i++) {
            int poppedValue = pop(sp);
            if (poppedValue != -1) {
                printf("Popped %d from the stack\n", poppedValue);
            }
        }
    }

    return 0;
}

Queue Basic 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct queue {
    int size;
    int f;
    int r;
    int *arr;
};

int isFull(struct queue *q) {
    if (q->r == q->size - 1) {
        return 1;
    } else {
        return 0;
    }
}

int isEmpty(struct queue *q) {
    if (q->r == q->f) {
        return 1;
    } else {
        return 0;
    }
}

void Enqueue(struct queue *q, int val) {
    if (isFull(q)) {
        printf("Queue is Full\n");
    } else {
        q->r++;
        q->arr[q->r] = val;
    }
}

int Dequeue(struct queue *q) {
    if (isEmpty(q)) {
        printf("Queue is Empty\n");
        return -1;  // Return a sentinel value to indicate queue is empty
    } else {
        q->f++;
        return q->arr[q->f];
    }
}

int main() {
    int n, val, p;

    // Allocate memory for the queue structure
    struct queue *q = (struct queue *)malloc(sizeof(struct queue));

    // Initialize the queue
    q->size = 100;
    q->f = q->r = -1;
    q->arr = (int *)malloc(q->size * sizeof(int));

    printf("Enter the number of values to be inserted: ");
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        printf("Enter the value %d: ", i + 1);
        scanf("%d", &val);
        Enqueue(q, val);
    }

    printf("Queue elements: ");
    for (int i = q->f + 1; i <= q->r; i++) {
        printf("%d ", q->arr[i]);
    }
    printf("\n");

    printf("Enter the number of values to be deleted: ");
    scanf("%d", &p);

    for (int i = 0; i < p; i++) {
        Dequeue(q);
    }

    printf("Queue elements: ");
    for (int i = q->f + 1; i <= q->r; i++) {
        printf("%d ", q->arr[i]);
    }
    printf("\n");

    return 0;
}

Circular Queue:
#include<stdio.h>
#include<stdlib.h>

struct queue{
    int size;
    int f;
    int r;
    int* arr;
};

int isFull(struct queue *q){
    if((q->r+1)%q->size==q->f){
        return 1;
    }else{
        return 0;
    }
}

int isEmpty(struct queue *q){
    if(q->r==q->f){
        return 1;
    }else{
        return 0;
    }
}

void enqueue(struct queue *q,int val){
    if(isFull(q)){
        printf("Queue is Full\n");
    }
    else{
        q->r=(q->r+1)%q->size;
        q->arr[q->r]=val;
    }
}

int dequeue(struct queue *q){
    int val=0;
    if(isEmpty(q)){
        printf("Queue is Empty");
    }
    else{
        q->f=(q->f+1)%q->size;
        val=q->arr[q->f];
    }
    return val;
}


int main(){
    struct queue *q;
    q->size = 4;
    q->f=q->r=-1;
    q->arr = (int*) malloc(q->size*sizeof(int));

    int val,n;
    printf("Enter the number of values to be inserted : ");
    scanf("%d",&n);

    for(int i=1;i<=n;i++){
        printf("Enter the value number %d : ",i);
        scanf("%d",&val);
        enqueue(q,val);
        }

    int n1;
    printf("Enter the number of values to be deleted : ");
    scanf("%d",&n1);

    for(int i=1;i<=n1;i++){
        printf("Dequeued: %d\n", dequeue(q));
        }

}
































            </pre>
        <br>
        
        <h1>Socket programming(python)</h1>
        <h3>server.py</h3>
        <pre>
            import socket

# Define the server address and port
HOST = '127.0.0.1'  # Localhost
PORT = 8080          # Port to listen on

# Create a socket object
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Bind the socket to the address and port
server_socket.bind((HOST, PORT))

# Listen for incoming connections (max 1 connection)
server_socket.listen(1)
print("Server is waiting for a connection...")

# Accept a connection from the client
client_socket, client_address = server_socket.accept()
print(f"Connection established with {client_address}")

# Send a "Hello" message to the client
message = "Hello, Client!"
client_socket.sendall(message.encode())  # Send encoded message

print(f"Sent message to client: {message}")

# Close the connection
client_socket.close()
server_socket.close()
            
        </pre>
        <br>
        <h3>client.py</h3>
        <pre>
            import socket

# Define the server address and port
HOST = '127.0.0.1'  # Localhost
PORT = 8080          # Port to connect to

# Create a socket object
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Connect to the server
client_socket.connect((HOST, PORT))

# Receive the message from the server
message = client_socket.recv(1024).decode()  # Receive and decode the message
print(f"Received from server: {message}")

# Close the socket
client_socket.close()

        </pre>


        <br>



        <h1>Socket programming(c language)</h1>
        <h3>server</h3>
        <pre>
                #include +stdio.h+
                #include +string.h+
                #include +stdlib.h+
                #include +unistd.h+
                #include +arpa/inet.h+
                                   
                #define PORT 5000
                
                int main() {
                    int server_fd, new_socket;
                    struct sockaddr_in address;
                    int addrlen = sizeof(address);
                    char *hello = "Hello";
                
                    // Create socket file descriptor
                    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
                        perror("socket failed");
                        exit(EXIT_FAILURE);
                    }
                
                    // Define server address
                    address.sin_family = AF_INET;
                    address.sin_addr.s_addr = INADDR_ANY;
                    address.sin_port = htons(PORT);
                
                    // Bind the socket to the address
                    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
                        perror("bind failed");
                        close(server_fd);
                        exit(EXIT_FAILURE);
                    }
                
                    // Listen for incoming connections
                    if (listen(server_fd, 3) < 0) {
                        perror("listen failed");
                        close(server_fd);
                        exit(EXIT_FAILURE);
                    }
                
                    printf("Server is listening on port %d\n", PORT);
                
                    // Accept a connection
                    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) < 0) {
                        perror("accept failed");
                        close(server_fd);
                        exit(EXIT_FAILURE);
                    }
                
                    // Send a "Hello" message to the client
                    send(new_socket, hello, strlen(hello), 0);
                    printf("Hello message sent\n");
                
                    // Close the socket
                    close(new_socket);
                    close(server_fd);
                    return 0;
                }
            
        </pre>
        <br>
        <h3>client</h3>
        <pre>
            #include +stdio.h+
                #include +string.h+
                #include +stdlib.h+
                #include +unistd.h+
                #include +arpa/inet.h+
                
                #define PORT 5000
                
                int main() {
                    int sock = 0;
                    struct sockaddr_in serv_addr;
                    char buffer[1024] = {0};
                
                    // Create socket file descriptor
                    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
                        printf("\n Socket creation error \n");
                        return -1;
                    }
                
                    // Define server address
                    serv_addr.sin_family = AF_INET;
                    serv_addr.sin_port = htons(PORT);
                
                    // Convert IPv4 and IPv6 addresses from text to binary form
                    if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0) {
                        printf("\nInvalid address/ Address not supported \n");
                        return -1;
                    }
                
                    // Connect to the server
                    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
                        printf("\nConnection Failed \n");
                        return -1;
                    }
                
                    // Read the message from the server
                    read(sock, buffer, 1024);
                    printf("Message from server: %s\n", buffer);
                
                    // Close the socket
                    close(sock);
                    return 0;
                }
        </pre>
    </div>


    <br>
    <h1>Go back N</h1>
    <pre>
        #include +stdio.h+
            #include +stdlib.h+
            
            void simulate_go_back_n(int total_frames, int window_size, int lost_frame) {
                int sent_frame = 0;  // Current frame being sent
                int ack_frame = 0;   // Last acknowledged frame
                int retransmit_start = 0; // Frame from where to start retransmission
            
                while (ack_frame < total_frames) {
                    printf("\nSender is sending frames...\n");
            
                    // Sender sends frames within the window size limit
                    for (int i = 0; i < window_size && sent_frame < total_frames; i++) {
                        if (sent_frame == lost_frame) {
                            printf("Frame %d is lost! Go-Back-N ARQ triggered!\n", sent_frame);
                            retransmit_start = lost_frame; // Set retransmission start point
                            break; // Stop sending further frames after losing the frame
                        }
                        printf("Frame %d sent.\n", sent_frame);
                        sent_frame++;
                    }
            
                    printf("\nReceiver is receiving and acknowledging frames...\n");
            
                    // Receiver processes received frames and acknowledges
                    for (int i = ack_frame; i < sent_frame; i++) {
                        if (i == lost_frame) {
                            printf("Receiver did not receive Frame %d. Discarding subsequent frames. Waiting for retransmission.\n", i);
                            sent_frame = retransmit_start; // Go back to the lost frame
                            break; // Exit loop to allow retransmission from the lost frame
                        } else {
                            printf("ACK for Frame %d received.\n", i);
                            ack_frame++;
                        }
                    }
            
                    // After retransmission of the lost frame, the receiver continues normally
                    if (ack_frame == lost_frame) {
                        lost_frame = -1; // Lost frame has been retransmitted and acknowledged
                    }
                }
            
                printf("\nAll frames successfully transmitted and acknowledged.\n");
            }
            
            int main() {
                int m, total_frames, window_size, lost_frame;
            
                printf("Go-Back-N Sliding Window Protocol Simulation\n");
            
                // Input the value of m first
                printf("\nEnter the value of m (for sequence numbers 2^m): ");
                scanf("%d", &m);
            
                // Window size calculation (2^m - 1)
                window_size = (1 << m) - 1; // Window size = 2^m - 1
            
                // Input the total number of frames
                printf("Enter total number of frames: ");
                scanf("%d", &total_frames);
            
                // Input the frame to be lost
                printf("Enter the frame number to be lost: ");
                scanf("%d", &lost_frame);
            
                if (lost_frame >= total_frames) {
                    printf("Frame number to be lost exceeds total frames.\n");
                    return 1;
                }
            
                printf("Window size: %d\n", window_size);
                printf("Frame %d is set to be lost.\n", lost_frame);
            
                // Simulate Go-Back-N
                simulate_go_back_n(total_frames, window_size, lost_frame);
            
                return 0;
            }
    </pre>

    <br>
    <h1>Selective</h1>
    <pre>
        #include +stdio.h+
            #include +stdlib.h+
            
            int main() {
                int total_frames;  // Total number of frames to be sent
                int *frames;       // Dynamic array to hold the frames
                int *ack;          // Dynamic array to hold the acknowledgment status for each frame
                int lost_frame;    // To store the frame number chosen to be lost
            
                // Ask the user for the number of frames
                printf("Enter the total number of frames to be sent: ");
                scanf("%d", &total_frames);
            
                // Allocate memory dynamically for frames and acknowledgment arrays
                frames = (int *)malloc(total_frames * sizeof(int));
                ack = (int *)malloc(total_frames * sizeof(int));
            
                // Check if memory allocation is successful
                if (frames == NULL || ack == NULL) {
                    printf("Memory allocation failed. Exiting program.\n");
                    return 1;
                }
            
                // Initialize frames and acknowledgment arrays
                for (int i = 0; i < total_frames; i++) {
                    frames[i] = i + 1;  // Frame numbers start from 1
                    ack[i] = 0;         // Initially, no frames are acknowledged
                }
            
                // Ask the user which frame should be "lost"
                printf("Enter the frame number to be lost (1 to %d): ", total_frames);
                scanf("%d", &lost_frame);
            
                // Validate user input
                if (lost_frame < 1 || lost_frame > total_frames) {
                    printf("Invalid frame number. Exiting program.\n");
                    free(frames);
                    free(ack);
                    return 1;
                }
            
                lost_frame -= 1; //
                printf("Sending frames...\n");
            
                // Simulate sending frames and receiving acknowledgments
                for (int i = 0; i < total_frames; i++) {
                    if (i == lost_frame) {
                        printf("Frame %d lost.\n", frames[i]);
                    } else {
                        printf("Frame %d sent and acknowledged.\n", frames[i]);
                        ack[i] = 1;  // Mark frame as acknowledged
                    }
                }
            
                // Check for lost frames and resend them
                printf("Resending lost frames...\n");
                for (int i = 0; i < total_frames; i++) {
                    if (ack[i] == 0) {
                        printf("Resending frame %d.\n", frames[i]);
                        ack[i] = 1;  // After resending, mark frame as acknowledged
                    }
                }
            
                // Final status
                printf("All frames have been successfully sent and acknowledged.\n");
            
                // Free the dynamically allocated memory
                free(frames);
                free(ack);
            
                return 0;
            }
    </pre>

    <br>
    <h1>Classification</h1>
    <pre>
        #include +stdio.h+
            #include +string.h+
            #include +stdlib.h+
            
            int find_ip_class(int first_octet) {
                if (first_octet >= 1 && first_octet <= 126) {
                    return 'A';  // Class A
                } else if (first_octet >= 128 && first_octet <= 191) {
                    return 'B';  // Class B
                } else if (first_octet >= 192 && first_octet <= 223) {
                    return 'C';  // Class C
                } else if (first_octet >= 224 && first_octet <= 239) {
                    return 'D';  // Class D (Multicast)
                } else if (first_octet >= 240 && first_octet <= 255) {
                    return 'E';  // Class E (Reserved)
                } else {
                    return 'U';  // Unknown
                }
            }
            
            char* find_ip_type(int first_octet, int second_octet) {
                // Check for private IP ranges
                if (first_octet == 10) {
                    return "Private";  // Class A private
                } else if (first_octet == 172 && (second_octet >= 16 && second_octet <= 31)) {
                    return "Private";  // Class B private
                } else if (first_octet == 192 && second_octet == 168) {
                    return "Private";  // Class C private
                } else {
                    return "Public";
                }
            }
            
            int main() {
                char ip_address[20];
                int octets[4];
            
                // Input the IP address
                printf("Enter an IP address (e.g., 192.168.1.1): ");
                scanf("%s", ip_address);
            
                // Parse the IP address 0into four octets
                sscanf(ip_address, "%d.%d.%d.%d", &octets[0], &octets[1], &octets[2], &octets[3]);
            
                // Find the class
                char ip_class = find_ip_class(octets[0]);
            
                // Find if it's private or public
                char *ip_type = find_ip_type(octets[0], octets[1]);
            
                // Output the results
                printf("IP Address: %s\n", ip_address);
                printf("Class: %c\n", ip_class);
                printf("Type: %s\n", ip_type);
            
                return 0;
            }
    </pre>

    <br>
    <h1>Djikstra</h1>
    <pre>
        #include +stdio.h+
            #include +limits.h+
            #define V 5 // Number of vertices in the graph
            
            // Find the vertex with the minimum distance value
            int minDistance(int dist[], int sptSet[]) {
                int min = INT_MAX, min_index;
            
                for (int v = 0; v < V; v++)
                    if (sptSet[v] == 0 && dist[v] <= min)
                        min = dist[v], min_index = v;
            
                return min_index;
            }
            
            // Function to print the shortest path
            void printPath(int parent[], int j) {
                // Base case: If j is the source node
                if (parent[j] == -1)
                    return;
            
                printPath(parent, parent[j]);
                printf(" -> %d", j);
            }
            
            // Dijkstra's algorithm to find the shortest path
            void dijkstra(int graph[V][V], int src, int dest) {
                int dist[V];     
                int sptSet[V];  
                int parent[V];   
                
                for (int i = 0; i < V; i++) {
                    dist[i] = INT_MAX;
                    sptSet[i] = 0;
                    parent[i] = -1;
                }
            
                dist[src] = 0; // Distance of source vertex from itself is always 0
            
                for (int count = 0; count < V - 1; count++) {
                    int u = minDistance(dist, sptSet); // Pick the minimum distance vertex
                    sptSet[u] = 1; // Mark the picked vertex as processed
            
                    for (int v = 0; v < V; v++) {
                        if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX 
                            && dist[u] + graph[u][v] < dist[v]) {
                            dist[v] = dist[u] + graph[u][v];
                            parent[v] = u; // Set parent for path tracing
                        }
                    }
                }
            
                // Print the shortest distance and path
                printf("Shortest path from node %d to %d is %d\n", src, dest, dist[dest]);
                printf("Path: %d", src);
                printPath(parent, dest);
                printf("\n");
            }
            
            int main() {
                int graph[V][V] = {{0, 10, 20, 0, 0},
                                   {10, 0, 5, 16, 0},
                                   {20, 5, 0, 2, 30},
                                   {0, 16, 2, 0, 8},
                                   {0, 0, 30, 8, 0}};
                
                int src, dest;
                
                // Take user input for source and destination nodes
                printf("Enter source node (0-%d): ", V-1);
                scanf("%d", &src);
                
                printf("Enter destination node (0-%d): ", V-1);
                scanf("%d", &dest);
                
                if (src >= 0 && src < V && dest >= 0 && dest < V) {
                    dijkstra(graph, src, dest);
                } else {
                    printf("Invalid input. Please enter nodes between 0 and %d.\n", V-1);
                }
            
                return 0;
            }
    </pre>

    <br>
    <h1>Djikstra(another method)</h1>
    <pre>
        #include +stdio.h+
            #include +stdbool.h+
            #include +limits.h+
            
            int no_vertices;
            
            void printGraph(int adj[][no_vertices]) {
                for (int i = 0; i < no_vertices; i++) {
                    for (int j = 0; j < no_vertices; j++) {
                        printf("%d ", adj[i][j]);
                    }
                    printf("\n");
                }
            }
            
            void insertPriorityQueue(int queue[], int distance[], int *size, int vertex) {
                queue[(*size)++] = vertex;
            
                for (int i = *size - 1; i > 0; i--) {
                    if (distance[queue[i]] > distance[queue[i - 1]]) {
                        // Swap
                        int temp = queue[i];
                        queue[i] = queue[i - 1];
                        queue[i - 1] = temp;
                    } else {
                        break;
                    }
                }
            }
            
            int extractMin(int queue[], int *size) {
                if (*size == 0) return -1; // Queue is empty
                return queue[--(*size)]; // Remove and return the minimum element
            }
            
            int main() {
                int s, d, dist;
            
                printf("\nEnter the number of vertices: ");
                scanf("%d", &no_vertices);
                int adj[no_vertices][no_vertices];
            
                for (int i = 0; i < no_vertices; i++) {
                    for (int j = 0; j < no_vertices; j++) {
                        adj[i][j] = 0;
                    }
                }
            
                while (true) {
                    printf("Enter an edge from node (0 to %d) to node (0 to %d) and its distance (-1 -1 to stop): ", no_vertices - 1, no_vertices - 1);
                    scanf("%d %d %d", &s, &d, &dist);
                    if (s == -1 && d == -1) {
                        break;
                    }
                    adj[s][d] = dist;
                    adj[d][s] = dist;
                }
            
                printGraph(adj);
            
                int z;
                int distance[no_vertices];
                int visited[no_vertices];
                int queue[no_vertices];
                int size = 0; // Size of the priority queue
            
                for (int i = 0; i < no_vertices; i++) {
                    visited[i] = 0;
                    distance[i] = INT_MAX; // Initialize distances to infinity
                }
            
                printf("\nEnter the source node: ");
                scanf("%d", &z);
                distance[z] = 0;
                insertPriorityQueue(queue, distance, &size, z); // Insert source node into the queue
            
                calculation(adj, queue, visited, distance, &size);
            
                printf("\nThe value in the distance list:");
                for (int i = 0; i < no_vertices; i++) {
                    printf("\nThe distance of the %d th node from the source is: %d", i, distance[i]);
                }
            
                return 0;
            }
            
            void calculation(int adj[][no_vertices], int queue[], int visited[], int distance[], int *size) {
                while (*size > 0) {
                    int z = extractMin(queue, size); // Get the node with the minimum distance
                    visited[z] = 1;
            
                    for (int i = 0; i < no_vertices; i++) {
                        if (adj[z][i] != 0 && visited[i] != 1) {
                            if (distance[z] + adj[z][i] < distance[i]) {
                                distance[i] = distance[z] + adj[z][i];
                                insertPriorityQueue(queue, distance, size, i); // Insert updated distance node
                            }
                        }
                    }
                    printf("%d ", z); // Print the visited node
                }
            }
            
    </pre>

    <h1>CRC0</h1>
    <pre>
        #include +stdio.h+
            #include +math.h+
            
            void main()
            {
                int divident[10];
                printf("Enter the block code:\n");
                for(int i=0;i<7;i++)
                {
                    scanf("%d",&divident[i]);
                }
            
                int length = 0;
                int divisor[4];
                printf("\nEnter the divisor:\n");
                for(int i=0;i<4;i++)
                {
                    scanf("%d",&divisor[i]);
                }
            
                for(int i=7;i<7+3;i++)
                {
                    divident[i] = 0;
                }
            
                int divlen = 3;
                int a[4],x[4];
                for(int i=0;i<4;i++)
                {
                    a[i] = divident[i];
                }
            
                for(int i=4;i<10;i++)
                {
                    if(a[0] == 1)
                    {
                        for(int i=0;i<4;i++)
                        {
                            if(a[i] == divisor[i])
                            {
                                x[i] = 0;
                            }
                            else
                            {
                                x[i] = 1;
                            }
                        }
            
                        for(int i=0;i<4;i++)
                        {
                            a[i] = x[i];
                        }
                    }
                    else if(a[0] == 0){}
            
                    else{
                        printf("kay teri chuklay bhava");
                    }
            
                    for(int i=0;i<3;i++)
                    {
                        a[i] = a[i+1];
                    }
                    a[3] = divident[i];
                }
            
                if(a[0] == 1)
                {
                    for(int i=0;i<4;i++)
                    {
                        if(a[i] == divisor[i])
                        {
                            x[i] = 0;
                        }
                        else
                        {
                            x[i] = 1;
                        }
                    }
            
                    for(int i=0;i<4;i++)
                    {
                        a[i] = x[i];
                    }
                }
                else if(a[0] == 0){}
            
                printf("\nCRC of given condition is:\n");
                for(int i=1;i<4;i++)
                {
                    printf("%d",a[i]);
                }
            }
            
            
    </pre>

    <h1>crc</h1>
    <pre>
        #include <stdio.h>
            #include <string.h>
            
            #define MAX 100
            
            // Function to perform XOR operation
            void xorOperation(char dividend[], char divisor[], int n) {
                for (int i = 0; i < n; i++) {
                    dividend[i] = (dividend[i] == divisor[i]) ? '0' : '1';
                }
            }
            
            // Function to perform CRC Division
            void crcDivision(char data[], char divisor[], char crc[]) {
                int dataLen = strlen(data);
                int divisorLen = strlen(divisor);
            
                char temp[MAX];
                strcpy(temp, data);
            
                for (int i = 0; i <= dataLen - divisorLen; i++) {
                    if (temp[i] == '1') {
                        xorOperation(temp + i, divisor, divisorLen);
                    }
                }
            
                strcpy(crc, temp + dataLen - divisorLen + 1);
            }
            
            // Function to check for errors
            int checkForErrors(char crc[]) {
                for (int i = 0; i < strlen(crc); i++) {
                    if (crc[i] == '1') {
                        return 1;  // Error found
                    }
                }
                return 0;  // No error
            }
            
            // Function to flip a bit in a string at a given position
            void flipBit(char data[], int pos) {
                data[pos] = (data[pos] == '1') ? '0' : '1';
            }
            
            int main() {
                char data[MAX], divisor[MAX], crc[MAX];
                int corrected = 0;
            
                printf("Enter the original data: ");
                scanf("%s", data);
            
                printf("Enter the divisor: ");
                scanf("%s", divisor);
            
                int dataLen = strlen(data);
                int divisorLen = strlen(divisor);
            
                // Append zeros to the data
                for (int i = 0; i < divisorLen - 1; i++) {
                    data[dataLen + i] = '0';
                }
                data[dataLen + divisorLen - 1] = '\0';
            
                // Perform CRC division
                crcDivision(data, divisor, crc);
            
                printf("CRC: %s\n", crc);
            
                // Simulate receiving data with CRC
                printf("Enter the received data (with CRC): ");
                scanf("%s", data);
            
                crcDivision(data, divisor, crc);
            
                if (checkForErrors(crc)) {
                    printf("Error detected. Attempting to correct...\n");
            
                    for (int i = 0; i < dataLen + divisorLen - 1; i++) {
                        flipBit(data, i);
                        crcDivision(data, divisor, crc);
            
                        if (!checkForErrors(crc)) {
                            printf("Error corrected! Corrected data: %s\n", data);
                            corrected = 1;
                            break;
                        }
            
                        // Flip the bit back if not corrected
                        flipBit(data, i);
                    }
            
                    if (!corrected) {
                        printf("Unable to correct the error.\n");
                    }
                } else {
                    printf("No error detected in the received data.\n");
                }
            
                return 0;
            }
    </pre>

    <template id="template-news-card">
        <div class="card">
            <div class="card-header">
                <img src="https://via.placeholder.com/400x200" alt="news-image" id="news-img">
            </div>
            <div class="card-content">
                <h3 id="news-title">This is the Title</h3>
                <h6 class="news-source" id="news-source">End Gadget 26/08/2023</h6>
                <p class="news-desc" id="news-desc">Lorem, ipsum dolor sit amet consectetur adipisicing elit. Recusandae saepe quis voluptatum quisquam vitae doloremque facilis molestias quae ratione cumque!</p>
            </div>
        </div>
    </template>

    <script src="script.js"></script>
</body>
</html>Â 
